use lib "/Users/davidbaxter/DATA/eFlora";
use flatten;
use BerkeleyDB::Hash;

open(IN, "/Users/davidbaxter/DATA/smasch_taxon_ids.txt") || die;
while(<IN>){
	chomp;
	s/X /&times;/;
	($smasch_code,$smasch_name,@residue)=split(/\t/);
	$TID{$smasch_name}=$smasch_code;
	$TNOAN{$smasch_code}=$smasch_name;
}
close(IN);

#use the key hash from Dick's version of the eflora to determine whether or not there is a key
#this is stored as "1 or Null" in my eflora taxa table in the field "HasKey"
#I'm sure there's a better way to do it once the key is actually stored in the database 
tie(%IJM_key, "BerkeleyDB::Hash", -Filename=>"/Users/davidbaxter/DATA/eFlora/IJM_key.hash", -Flags      => DB_CREATE )|| die "Stopped; couldnt open IJM_key\n";

#process the bioregion hex code file, generated by get_all_dist.pl
open(IN, "outputs/dist_codes.txt") || die;
while(<IN>){
	$hex_code="";
	chomp;
	($hex_ID, $hex_code) = split(/\t/);
	$HEX{$hex_ID} = $hex_code;
}
close(IN);

#store the CNPS_ID field in a hash
open(IN, "/Users/davidbaxter/DATA/Interchange/CNPS_ID.txt") || die;
while(<IN>){
	$CNPS_ID="";
	$CNPS_name="";
	chomp;

	($CNPS_ID,
	$CNPS_name) = split(/\t/);
	
	foreach($CNPS_name){
		s/ ssp\. / subsp. /;
	}
	
	$CNPS{$CNPS_name} = $CNPS_ID;
}
close(IN);

#this function indicates the record delimiter. In this case, an empty line
#as such, it needs to be designated after the other files are processed
$/="";

open(OUT, ">outputs/load_main_table.sql") || die;

#This file is made here and subsequently used by the synonymy script
open(FILE, ">outputs/accepted_name_list.txt") || die;

open(IN, "/Users/davidbaxter/DATA/eFlora/eflora_treatments.txt") || die;
while(<IN>){
     next if m/^#/; #skip lines that are commented out
     next if m/^Admin/;	#skip lines that start with Admin

#replace underscore italics indicators with HTML italics tags. Maybe this should be done in PHP?
	s/_n_/<i>n<\/i>/g;

	s/ _/ <i>/g;
	s/\(_/\(<i>/g;
	s/"_/"<i>/g;
	s/\[_/\[<i>/g;
	s/\/_/\/<i>/g;
	s/,_/,<i>/g;
	s/;_/;<i>/g;
	
	s/_ /<\/i> /g;
	s/_"/<\/i>"/g;
	s/_\]/\]<\/i>/g;
	s/_,/<\/i>,/g;
	s/_\./<\/i>./g;
	s/_\)/<\/i>\)/g;
	s/_;/<\/i>;/g;
	s/_:/<\/i>:/g;
	s/_-/<\/i>-/g;
	s/_\//<\/i>\//g;
	s/_\n/<\/i>\n/g;

#Escaping single quotes for SQL insert
	s/'/''/g;

if(m/([A-Z]+ACEAE)/){ #when it encounters a CAPS string ending in ACEAE
$family=$1; #that word is assigned to $family (until it gets reassigned)
}

#The contents of many tags are retrieved with the generalized "&basic_get" subroutine
	$plant_body=&basic_get($_, "PLANT BODY");
	$sterile_stem=&basic_get($_, "STERILE STEM");
	$fertile_stem=&basic_get($_, "FERTILE STEM");
	$staminate_head=&basic_get($_, "STAMINATE HEAD");
	$ray_or_pistillate_flower=&basic_get($_, "RAY OR PISTILLATE FLOWER");
	$pistillate_head=&basic_get($_, "PISTILLATE HEAD");
	$staminate_inflorescence=&basic_get($_, "STAMINATE INFLORESCENCE");
	$pistillate_or_bisexual_inflorescence=&basic_get($_, "PISTILLATE OR BISEXUAL INFLORESCENCE");
	$pistillate_inflorescence=&basic_get($_, "PISTILLATE INFLORESCENCE");
	$fertile_spikelet=&basic_get($_, "FERTILE SPIKELET");
	$sterile_spikelet=&basic_get($_, "STERILE SPIKELET");
	$distal_spikelet=&basic_get($_, "DISTAL SPIKELET");
	$central_spikelet=&basic_get($_, "CENTRAL SPIKELET");
	$lateral_spikelet=&basic_get($_, "LATERAL SPIKELET");
	$staminate_spikelet=&basic_get($_, "STAMINATE SPIKELET");
	$pistillate_spikelet=&basic_get($_, "PISTILLATE SPIKELET");
	$staminate_flower=&basic_get($_, "STAMINATE FLOWER");
	$pistillate_flower=&basic_get($_, "PISTILLATE FLOWER");
	$ray_flower=&basic_get($_, "RAY FLOWER");
	$pollen_cone=&basic_get($_, "POLLEN CONE");
	$seed_cone=&basic_get($_, "SEED CONE");
	$bisexual_flower=&basic_get($_, "BISEXUAL FLOWER");
	$fruit=&basic_get($_, "FRUIT");
	$seed=&basic_get($_, "SEED");
	$sporangia=&basic_get($_, "SPORANGIA");
	$male_sporangium_case=&basic_get($_, "MALE SPORANGIUM CASE");
	$female_sporangium_case=&basic_get($_, "FEMALE SPORANGIUM CASE");
	$spores=&basic_get($_, "SPORES");
	$ecology=&basic_get($_, "ECOLOGY");
	$elevation=&basic_get($_, "ELEVATION");
	$toxicity=&basic_get($_, "TOXICITY");
	$unabridged_synonyms=&basic_get($_, "UNABRIDGED SYNONYMS");
	$unabridged_note=&basic_get($_, "UNABRIDGED NOTE");
	$flowering_time=&basic_get($_, "FLOWERING TIME");
	$fruiting_time=&basic_get($_, "FRUITING TIME");
	$coning_time=&basic_get($_, "CONING TIME");
	$weediness=&basic_get($_, "WEEDINESS");
	
#The remaining tags have dedicated "&get" subroutines"
	$taxon_name= &get_taxon_name($_);
	$taxon_author=&get_taxon_author($_);
	$common_name=&get_common_name($_);
	$key_group=&get_key_group($_);
	$native_status=&get_native_status($_);
	$TJM2_author=&get_TJM2_author($_);
	$scientific_editor=&get_scientific_editor($_);
	$habit=&get_habit($_);
	$stem=&get_stem($_);
	$leaf=&get_leaf($_);
	$spines=&get_spines($_);
	$inflorescence=&get_inflorescence($_);
	$spikelet=&get_spikelet($_);
	$flower=&get_flower($_);
	$disk_flower=&get_disk_flower($_);
	$cone=&get_cone($_);
	$sporangium_case=&get_sporangium_case($_);
	$chromosomes= &get_chromosomes($_);	

	$bioregional_distribution=&get_bioregion($_);
	$outside_CA=&get_outside_CA($_);
	$species_in_genus=&get_species_in_genus($_);
	$genera_in_family=&get_genera_in_family($_);
	$etymology=&get_etymology($_);
	$synonyms=&get_synonyms($_);
	$note=&get_note($_);
	$ft_code=&get_flowering_time_code($_); #fetches the flowering time in the format needed for the "heath bar" display script
	$is_terminal_taxon=&is_terminal_taxon($_);
	$revision_number=&get_revision_number($_); #revision number is assigned based on which "TJM# AUTHOR" tags are used


#the $full_formatted_display_name is the full name including authors and italics tags
#this is required since autonyms have their authority inserted after the species
#and infra taxa lacking a species treatment (ILST) need to have the species author included
#for display purposes (but not searching).

#This is tricky because you need to titlecase the genus separately for ILST names
#otherwise the authority gets all lowercased

if ($taxon_name =~ /ENCELIA farinosa &times; E. frutescens/){ #the spontaneous hybrid is kluged because there is only one and it's awkward
	$taxon_name = "Encelia farinosa &times; E. frutescens";
	$full_formatted_display_name = "<i>Encelia farinosa</i> &times; <i>E. frutescens</i>";
}
elsif ($taxon_name =~ /([A-Z]+) ([a-z-]+) (.+) (var\.|subsp\.) ([a-z-]+)$/){ #if it is an infra with an author inserted (that's the ".+")
	$genus = ucfirst(lc($1));
	$species = $2;
	$species_author = $3;
	$infra_rank = $4;
	$infra_epithet = $5;
	$taxon_name=ucfirst(lc($taxon_name));
	$taxon_name=&strip_name($taxon_name);
	if ($species eq $infra_epithet){ #if it is an autonym, inserted author goes after specific epithet, and there is no $taxon_author
		$full_formatted_display_name = "<i>$genus $species</i> $species_author $infra_rank <i>$infra_epithet</i>";
	}
	else { #else the inserted author stays after the specific epithet, and the $taxon_author goes at the end
		$full_formatted_display_name = "<i>$genus $species</i> $species_author $infra_rank <i>$infra_epithet</i> $taxon_author";
	}
}
elsif ($taxon_name =~ /([A-Z]+) ([a-z-]+) (var\.|subsp\.) ([a-z-]+)$/){ #if it is an infra without an author in the name
	$genus = ucfirst(lc($1));
	$species = $2;
	$infra_rank = $3;
	$infra_epithet = $4;
	$taxon_name=ucfirst(lc($taxon_name));
	if ($species eq $infra_epithet){ #if it is an autonym, author goes after specific epithet
		$full_formatted_display_name = "<i>$genus $species</i> $taxon_author $infra_rank <i>$infra_epithet</i>";
	}
	else { #otherwise the author goes at the end
		$full_formatted_display_name = "<i>$genus $species</i> $infra_rank <i>$infra_epithet</i> $taxon_author";
	}
}
else { #The rest should be family, genus, or binomial species treatments
	$taxon_name=ucfirst(lc($taxon_name));
	$taxon_name=&strip_name($taxon_name);
	if ($taxon_author eq "NULL"){
		$full_formatted_display_name = "<i>$taxon_name</i>";
	}
	else {
		$full_formatted_display_name = "<i>$taxon_name</i> $taxon_author";
	}
}

$family=ucfirst(lc($family));

#Some families have alternate names in parens, e.g. "Asteraceae (Compositae)"
#first, make sure the alternate name is capitalized correctly
if ($taxon_name =~ /([A-Za-z]+) \((.*)\)/){ #can't have the parens as part of $2, otherwise the ucfirst function will target the open paren
	$taxon_name = $1 . " " . "(" . ucfirst($2) . ")"; 
} 
#then before matching to taxon ids, create a name_for_matching that removes the alternate name
$name_for_matching = $taxon_name;
foreach ($name_for_matching){
	s/ \(.*\)//;
	s/&times; ([A-Z])/&times;$1/;
}

$taxon_id=$TID{$name_for_matching};
next unless $taxon_id;

#print out the plain matched taxon names to file used by synonymy script
print FILE "$name_for_matching\n";

#test print
#print "$taxon_id\t$taxon_name\t$taxon_author\t$full_formatted_display_name\n";
#print "<tr><td>$taxon_id</td><td>$taxon_name</td><td>$taxon_author</td><td>$full_formatted_display_name</td</tr>\n";

#add single quotes to fields that were used for processing
$taxon_name="\'$taxon_name\'";
$taxon_author="\'$taxon_author\'" unless $taxon_author eq "NULL";
$full_formatted_display_name="\'$full_formatted_display_name\'";

#dist_codes are a shorter hexidecimal representation of a 40-character binary vector
#the 40 character vector indicates the presence or absence of a taxon in a bioregion
#the first 35 represent the 35 bioregions; the last five are blank spots (always 0)
#get_all_dist.pl translates bioregion distribution strings into the binary vector and packs it into hex
#here we unpack the hex so we can also store the binary vector in the database
#the binary is used by the online "checklist builder" pages
$dist_code=$HEX{$taxon_id};
$dist_code = &format_for_SQLite($dist_code);

$dist_array = unpack("b*",pack("H*",$HEX{$taxon_id}));
$dist_array = &format_for_SQLite($dist_array);


#use $taxon_id to determine whether there is a key or not
if($IJM_key{$taxon_id}){
	$has_key="1";
}
else{
	$has_key="NULL";
}

#rarity must be fetched last because it needs the $name_for_matching
	$rarity_status= &get_rarity($_);

#print "$taxon_name\t$has_key\n";
#print "$name\t$family\t$bioregion\t$elev\t$ecol\t$flow_per\t$outside_CA\n";
#print "$family\t$name\t$common_name\t$native_status\t$rarity\t$weediness\t$bioregion\n";
#print "$inflorescence\n"
#print join("\t",$name,@hv[0 .. 34]), "\n";
#print "$taxon_id\t$taxon_name\t$taxon_author\t$common_name\t$native_status\t$TJM2_author\t$habit\t$plant_body\t$stem\t$sterile_stem\t$fertile_stem\t$leaf\t$spines\t$inflorescence\t$staminate_head\t$ray_or_pistillate_flower\t$pistillate_head\t$staminate_inflorescence\t$pistillate_or_bisexual_inflorescence\t$pistillate_inflorescence\t$spikelet\t$fertile_spikelet\t$sterile_spikelet\t$distal_spikelet\t$central_spikelet\t$lateral_spikelet\t$staminate_spikelet\t$pistillate_spikelet\t$flower\t$staminate_flower\t$pistillate_flower\t$ray_flower\t$disk_flower\t$cone\t$pollen_cone\t$seed_cone\t$bisexual_flower\t$fruit\t$seed\t$sporangia\t$sporangium_case\t$male_sporangium_case\t$female_sporangium_case\t$spores\t$chromosomes\t$ecology\t$rarity_status\t$elevation\t$bioregional_distribution\t$outside_CA\t$species_in_genus\t$genera_in_family\t$etymology\t$toxicity\t$synonyms\t$unabridged_synonyms\t$note\t$unabridged_note\t$flowering_time\t$fruiting_time\t$coning_time\t$weediness\t$is_terminal_taxon\t$has_key, $revision_number, $dist_code\n";
#print "$taxon_name\t$taxon_id\n";
#print "$taxon_name\t$common_name\t$taxon_author\t$key_group\n";
#print "$taxon_name\t$taxon_id\t$dist_code\n";
#print "$taxon_id\t$bioregional_distribution\t$dist_code\t$dist_array\n";
#print "$taxon_id\t$taxon_name\t$full_formatted_display_name\n";


print OUT "INSERT INTO eflora_taxa(TaxonID, ScientificName, TaxonAuthor, FormattedDisplayName, CommonName, KeyGroup, NativeStatus, TJM2Author, ScientificEditor, Habit, PlantBody, Stem, SterileStem, FertileStem, Leaf, Spines, Inflorescence, StaminateHead, RayOrPistillateFlower, PistillateHead, StaminateInflorescence, PistillateOrBisexualInflorescence, PistillateInflorescence, Spikelet, FertileSpikelet, SterileSpikelet, DistalSpikelet, CentralSpikelet, LateralSpikelet, StaminateSpikelet, PistillateSpikelet, Flower, StaminateFlower, PistillateFlower, RayFlower, DiskFlower, Cone, PollenCone, SeedCone, BisexualFlower, Fruit, Seed, Sporangia, SporangiumCase, MaleSporangiumCase, FemaleSporangiumCase, Spores, Chromosomes, Ecology, RarityStatus, Elevation, BioregionalDistribution, OutsideCA, SpeciesInGenus, GeneraInFamily, Etymology, Toxicity, Synonyms, UnabridgedSynonyms, Note, UnabridgedNote, FloweringTime, FloweringTimeCode, FruitingTime, ConingTime, Weediness, IsTerminalTaxon, HasKey, RevisionNumber, DistCode, DistArray)\n";
print OUT "VALUES($taxon_id, $taxon_name, $taxon_author, $full_formatted_display_name, $common_name, $key_group, $native_status, $TJM2_author, $scientific_editor, $habit, $plant_body, $stem, $sterile_stem, $fertile_stem, $leaf, $spines, $inflorescence, $staminate_head, $ray_or_pistillate_flower, $pistillate_head, $staminate_inflorescence, $pistillate_or_bisexual_inflorescence, $pistillate_inflorescence, $spikelet, $fertile_spikelet, $sterile_spikelet, $distal_spikelet, $central_spikelet, $lateral_spikelet, $staminate_spikelet, $pistillate_spikelet, $flower, $staminate_flower, $pistillate_flower, $ray_flower, $disk_flower, $cone, $pollen_cone, $seed_cone, $bisexual_flower, $fruit, $seed, $sporangia, $sporangium_case, $male_sporangium_case, $female_sporangium_case, $spores, $chromosomes, $ecology, $rarity_status, $elevation, $bioregional_distribution, $outside_CA, $species_in_genus, $genera_in_family, $etymology, $toxicity, $synonyms, $unabridged_synonyms, $note, $unabridged_note, $flowering_time, $ft_code, $fruiting_time, $coning_time, $weediness, $is_terminal_taxon, $has_key, $revision_number, $dist_code, $dist_array)\n";
print OUT ";\n";
}






###########################################

sub format_for_SQLite {
	#given exactly one variable
	#if the variable has contents, put single quotes around the string
	#else, return "NULL" without quotes
	my ($input) = @_;
	if ($input){
		return "\'$input\'";
	}
	else {
		return "NULL";
	}
}

sub strip_name {
	local($_) = @_;
	s/^([A-Z][-a-z]+) (X?[-a-z]+).*(subsp\.|ssp\.|var\.|f\.) ([-a-z]+).*/$1 $2 $3 $4/ ||
	s/^([A-Z][a-z]+) ([x ]*[-a-z]+).*/$1 $2/;
	s/ssp\./subsp./;
	return ($_);
}

sub basic_get {
	#for tags that don't require any special processing
	#the following basic formula is used
	#given the tage name as a second variable
	my($paragraph, $tag) = @_;
	if($paragraph =~ /$tag: *(.*)/){
		return "\'$1\'";
	}
	else {
		return "NULL";
	}
}

sub get_taxon_name {
    my $par = shift; #each paragraph is separated by a blank line
    @lines=split(/\n/,$par); #the array of lines within a paragraph are values separated by a new line
    if( $lines[0]=~/^NATIVE|NATURALIZED/){ #if the first line starts with...
        return $lines[1]; #the name is the contents of the second line
    }
    if( $lines[0]=~/^WAIF/){ #if the first line starts with...
        return $lines[1]; #the name is what's on the second line
    }
    elsif($lines[1]=~/^(WAIF|AGRICULTURAL WEED|URBAN WEED|EXTIRPATED ALIEN|HISTORICAL WAIF|JFP-4|SPONTANEOUS HYBRID|JFP-8, does not occur in CA|GARDEN AND URBAN WEED|EXTIRPATED WAIF|AGRICULTURAL, GARDEN, OR URBAN WEED|URBAN WEED EXPECTED IN WILDLANDS|JFP-8, accepted name for taxon not occurring in California|JFP-4, URBAN WEED|GARDEN WEED|EXTIRPATED WEED|CULTIVATED PLANT|EXTIRPATED)/){
        return $lines[2]; #elsif the second line starts with any of the above values, the name is what's on the third line
    }
    elsif($lines[0]=~/UNABRIDGED/){ #elsif the first line starts with "UNABRIDGED"
        return $lines[1]; #the name is what's on the second line
    }
    elsif( $lines[0]=~/^[A-Z][A-Z][A-Z]/){ #elsif the first line starts with three capital letters...
        return $lines[0] #the name is what's on the first line
    }
    else{ #otherwise...
        return "NULL"; #don't return anything for that paragraph
    }
}

sub get_taxon_author {
# taxon author is returned without single quotes, since it is used to generate the formatted display name
# single quotes are added later in the script
		my $par = shift;
		if($par=~/TAXON AUTHOR: *\n/){
			return "NULL";
		}
		elsif ($par=~/TAXON AUTHOR: *(.*) (\(Group.*\))/){
			return "$1";
		}
		elsif($par=~/TAXON AUTHOR: *(.*)/){
			return "$1";
		}
		else{
		return "NULL";
		}
}

sub get_common_name {
		my $par = shift;
		if($par=~/COMMON NAME: *(.*) (\(Group.*\))/){
			return "\'$1\'";
		}
		elsif($par=~/COMMON NAME: *(.*)/){
			return "\'$1\'";
		}
		else{
		return "NULL";
		}
}

sub get_key_group { #Key Group comes at the end of the common name. If no common name, it's at the end of the taxon author
	my $par = shift;
	if($par=~/COMMON NAME: *(.*) \((Group.*)\)/){
			return "\'$2\'";
		}
	elsif($par=~/TAXON AUTHOR: *(.*) \((Group.*)\)/){
			return "\'$2\'";
		}
	else{
		return "NULL";
	}
}

sub get_native_status {
    my $par = shift; #each paragraph is separated by a blank line
    @lines=split(/\n/,$par); #the array of lines within a paragraph are values separated by a new line
    if( $lines[0]=~/^NATIVE|NATURALIZED/){ #if the first line starts with...
        return "\'$lines[0]\'"; #the name is the contents of the second line
    }
    if( $lines[0]=~/^WAIF/){ #if the first line starts with...
        return "\'$lines[0]\'"; #the name is what's on the second line
    }
    elsif($lines[1]=~/^(WAIF|AGRICULTURAL WEED|URBAN WEED|EXTIRPATED ALIEN|HISTORICAL WAIF|JFP-4|SPONTANEOUS HYBRID|JFP-8, does not occur in CA|GARDEN AND URBAN WEED|EXTIRPATED WAIF|AGRICULTURAL, GARDEN, OR URBAN WEED|URBAN WEED EXPECTED IN WILDLANDS|JFP-8, accepted name for taxon not occurring in California|JFP-4, URBAN WEED|GARDEN WEED|EXTIRPATED WEED|CULTIVATED PLANT)/){
        return "\'$lines[1]\'"; #elsif the second line starts with any of the above values, the name is what's on the third line
    }
    else {
    	return "NULL";
    }
}

sub get_TJM2_author {
		my $par = shift;
		if($par =~ /TJMXXX AUTHOR: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJMXX AUTHOR: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJMX AUTHOR: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~/TJM2 AUTHOR: *(.*)/){
			return "\'$1\'";
		}
		else{
			return "NULL";
		}
}

sub get_scientific_editor {
		my $par = shift;
		if($par =~ /SCIED: Scientific Editors?: *(.*)/){
			return "\'$1\'";
		}
		else{
			return "NULL";
		}	
}

sub get_habit {
		my $par = shift;
		if($par=~/HABIT\+: *(.*)/ && $par =~ /UNABRIDGED HABIT\+: *(.*)/){
			return "\'$1; $2\'";
		}
		elsif($par=~/HABIT\+: *\n/){ #The HABIT+ tag is always included, even if empty
			return "NULL";
		}
		elsif($par=~/HABIT\+: *(.*)/){
			return "\'$1\'";
		}
		else{
			return "NULL";
		}
}

sub get_stem {
		my $par = shift;
		if($par =~ /([\H])STEM: *(.*)/){
			return "\'$2\'";
		}
		elsif($par =~ /STEMS: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_leaf {
		my $par = shift;
		if($par =~ /LEAF: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /LEAVES: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_spines {
		my $par = shift;
		if($par =~ /SPINES: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /SPINE: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_inflorescence {
		my $par = shift;
		if($par =~ /([\H])INFLORESCENCE: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_spikelet {
		my $par = shift;
		if($par =~ /([\H])SPIKELET: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_flower {
		my $par = shift;
		if($par =~ /UNABRIDGED FLOWER: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /([\H])FLOWER: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_disk_flower {
		my $par = shift;
		if($par =~ /([\H])DISK FLOWER: *(.*)/ && $par =~ /UNABRIDGED DISK FLOWER: *(.*)/){
			return "\'$2; $3\'";
		}
		elsif($par =~/([\H])DISK FLOWER: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_cone {
		my $par = shift;
		if($par =~ /([\H])CONE: *(.*)/){
			return "\'$2\'";
		}
		elsif($par =~ /CONES: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_sporangium_case {
		my $par = shift;
		if($par =~ /SPORANGIUM CASE: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /SPORANGIUM CASES: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_chromosomes {
		my $par = shift;
		if($par =~ /([\H])CHROMOSOMES: *(.*)/ && $par =~ /UNABRIDGED CHROMOSOMES: *(.*)/){
			return "\'$2; $3\'";
		}
		elsif($par =~ /UNABRIDGED CHROMOSOMES: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /([\H])CHROMOSOMES: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_rarity {
#This stores the CNPS database ID for records with rarity status
#or if the ID is not available, the search terms to put in the CNPS search URL
		my $par = shift;
		if($par=~/RARITY STATUS: *(.*)/){
			if ($CNPS{$name_for_matching}) {
				return "\'$CNPS{$name_for_matching}\'";
			}
			else {
				$name_for_matching=~s/ subsp\. / ssp. /;
				$name_for_matching=~s/ /\+/;
				return "\'$name_for_matching\'";
			}
		}
		else{
				return "NULL";
		}
}

sub get_bioregion {
		my $par = shift;
		if($par=~/UNABRIDGED BIOREGIONAL DISTRIBUTION: *(.*)/){
			return "\'$1\'";
		}
		elsif($par=~/BIOREGIONAL DISTRIBUTION: *(.*)/){
			return "\'$1\'";
		}
		else{
		return "NULL";
		}
}

sub get_outside_CA {
		my $par = shift;
        if($par=~ m/UNABRIDGED DISTRIBUTION OUTSIDE CALIFORNIA: *(.*)/){
                return "\'$1\'";
        }
        elsif($par=~ m/DISTRIBUTION OUTSIDE CALIFORNIA: *(.*)/){
                return "\'$1\'";
        }
        else{
                return "NULL";
        }
}

sub get_species_in_genus {
		my $par = shift;
		if($par =~ /UNABRIDGED SPECIES IN GENUS: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /SPECIES IN GENUS: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_genera_in_family {
		my $par = shift;
		if($par =~ /UNABRIDGED GENERA IN FAMILY: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /GENERA IN FAMILY: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_etymology {
		my $par = shift;
		if($par =~ /UNABRIDGED ETYMOLOGY: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /ETYMOLOGY: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_synonyms {
		my $par = shift;
		if($par =~ /([\H])SYNONYMS: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_note {
		my $par = shift;
		if($par =~ /([\H])NOTE: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_flowering_time_code {
        my $entry = shift;
        undef @FT; 
        my @FT; #This needs to be done outside the loops, otherwise in cases where there are multiple ranges, the array will be overwritten
        if($entry=~/([A-Z][a-z][a-z])--([A-Z][a-z][a-z])/){ #searches the whole entry for ranges, because e.g. Coning time is recorded in the NOTES field
        	%monthno=("Jan",0,"Feb",1,"Mar",2,"Apr",3,"May",4,"Jun",5,"Jul",6,"Aug",7,"Sep",8,"Oct",9,"Nov",10,"Dec",11); #heath bar index starts at 0
            if($monthno{$1} > $monthno{$2}){
                foreach $no (0 .. $monthno{$2}){
                    push @FT, $no; 
                }
                foreach $no ($monthno{$1} .. 11){
                    push @FT, $no;
                }
            }
            else{
                foreach $no ($monthno{$1} .. $monthno{$2}){
                	push @FT, $no;
                }      
            }
            $FTCODE = join (",", @FT);
        	return "\'$FTCODE\'"; 
        }
        else{
            return "NULL";
        }
}

sub is_terminal_taxon {
        my $par = shift;
		if ($par=~ m/BIOREGIONAL DISTR/){
        	return 1;
        }
		else{
			return "NULL";
		}
}

sub get_revision_number {
	my $par = shift;
	if ($par =~ m/TJMXXX AUTHOR:/){
		return "\'Revision 3\'";
	}
	elsif ($par =~ m/TJMXX AUTHOR:/){
		return "\'Revision 2\'";
	}
	elsif ($par =~ m/TJMX AUTHOR:/){
		return "\'Revision 1\'";
	}
	else {
		return "NULL";
	}
}