#In all cases where the 'sub get_taxon_name' is present in the eflora, Zeltnera arizonica fails to parse, including the custom parsing scripts.
#Zeltnera arizonica is a native that is extirpated.  It is not parsing into the index or onto species pages in the flora.  This code below does not accept this format:
#NATIVE
#EXTIRPATED
#ZELTNERA arizonica
#TAXON AUTHOR: (A. Gray) G. Mans.
#Native species check for Native on line 0 and report the name on line 1, this is skipping the taxon name in this case.
#It is the only extirpated native in the eflora as of 2017, the others are unabridged and they are catgorized as 'WEED' or 'ALIEN'.

use BerkeleyDB::Hash;
#use warnings;
use strict;
use BerkeleyDB;
use lib "/Users/Shared/Jepson-Master/Jepson-eFlora/Modules/";
use flatten;
use CCH;

my %TNOAN;
my %IJM_key;
my %HEX;
my %KEYTABLE;
my %CNPS;
my @lines;
my @FT;
my %TID;
my %monthno;
my %seen;
my ($names, $key, $smasch_code, $smasch_name, @residue, $hex_code, $hex_ID, $HEX, $k, $v, $CNPS_ID, $CNPS_name) = "";
my ($full_formatted_display_name, $genus, $species, $species_author, $infra_rank, $infra_epithet, $name_for_matching, $family) = "";
my ($dist_code, $taxon_id, $dist_array, $has_key, $rarity_status, $no, $FTCODE, $hexkey, $tName, $todayJD, $log_file) = "";
my ($count_lines, $rare, $fam_lines, $count, $NFM, $DIST_NULL) = "";


$todayJD = &CCH::get_today_julian_day;
$log_file = 'output/eflora_log'.$todayJD.'.txt';
	open(LOG, '>', $log_file);


open(IN, "/Users/Shared/Jepson-Master/Jepson-eFlora/synonymy/input/smasch_taxon_ids.txt") || die;
while(<IN>){
	chomp;
	s/X /&times;/;
	($smasch_code,$smasch_name,@residue)=split(/\t/);
	$TNOAN{$smasch_name}=$smasch_code;
	$TID{$smasch_code}=$smasch_name;
	
}
close(IN);

print "Hybrid Check==>".$TID{93861}."\n\n";
print LOG "Hybrid Check==>".$TID{93861}."\n\n";
#use the key hash from Dick's version of the eflora to determine whether or not there is a key
#this is stored as "1 or Null" in Baxter's eflora taxon table in the field "HasKey"
#DB note: I am sure there's a better way to do it once the key is actually stored in the database 
tie(%IJM_key, "BerkeleyDB::Hash", -Filename=>"/Users/Shared/Jepson-Master/Jepson-eFlora/eflora_keys/output/IJM_key.hash", -Flags      => BerkeleyDB::DB_CREATE )|| die "Stopped; couldnt open IJM_key\n";

#this script used to process the bioregion hex code file, generated by get_all_dist_local.pl 
# and used a cumulative hash file
#however, this script no longer works due to technical reasons due to the upgrading of
#CCH and the eFlora to a database instead of a hash file
#the file below is generated from the new process 'get_HCODES.sh'
open(IN, "/Users/Shared/Jepson-Master/Jepson-eFlora/YELLOW_FLAGGING/output/tid_accepted_HCODE_cch_out.txt") || die;
while(<IN>){
	#$hex_code="";
	#s/X /&times;/;
	chomp;
	($key, $tName, $hex_code) = split(/\t/);

	next if $seen{$key}++; 
	#we only want one value per taxon ID to be loaded.
	#due to errors the old version of this file
	#often had duplicate TID'S with different HCODES,
	#this selected the first found, which may or may not have been the correct HCODE

		$HEX{$key} = $hex_code;


print LOG "$_ $HEX{$_}\n" if m/^1831/;
print LOG "$_ $HEX{$_}\n" if m/eria naus/;
print LOG "$_ $HEX{$_}\n" if m/ X /;
print LOG "$_ $HEX{$_}\n" if m/ &times;/;


print "TEST RECORD FOUND: $key $HEX{$key}\n" if ($hex_code =~ m/6000048102/);
print LOG "TEST RECORD FOUND: $key $HEX{$key}\n" if ($hex_code =~ m/6000048102/);


}
close(IN);




open(IN, "../eflora_keys/output/eflora_keys_expanded.html") || die;
while(<IN>){
		s/ (\d+) px ;/ $1px ;/g;
    chomp;
    ($k,$v) = (split /\t/,$_);
    if (exists $KEYTABLE{$k} ) {
        $KEYTABLE{$k}.= $v;
    }
    else{
        $KEYTABLE{$k} = $v;
    }    
}
close(IN);


#my $hfile="/JEPS-master/Jepson-eFlora/synonymy/input/nomsyn_hcode_hash";
#	tie %HEX, "BerkeleyDB::Hash", -Filename => $hfile, -Flags    => DB_CREATE or die "Cannot open file $hfile: $! $BerkeleyDB::Error\n" ;
#foreach(keys(%HEX)){
#print "$_ $HEX{$_}\n" if m/1831/;
#print "$_ $HEX{$_}\n" if m/eria naus/;
#print "$_ $HEX{$_}\n" if m/ X /;
#print "$_ $HEX{$_}\n" if m/ &times;/;
#}

#while(($key,$hex_code)=each(%HEX)){
#print "TEST RECORD FOUND: $hexkey $HEX{$hexkey}\n" if ($hex_code =~ m/6000048102/);
#print "TEST RECORD FOUND: $hexkey $HEX{$hexkey}\n" if ($hex_code =~ m/ffffffff07/);
#}

#store the CNPS_ID field in a hash
open(IN, "/Users/Shared/Jepson-Master/Interchange/input/CNPS/CNPS_ID_master.txt") || die;
while(<IN>){
	$CNPS_ID="";
	$CNPS_name="";
	s/X /&times;/;
	chomp;

	($CNPS_ID,
	$CNPS_name) = split(/\t/);
	
	foreach($CNPS_name){
		s/ ssp\. / subsp. /;
	}
	
	$CNPS{$CNPS_name} = $CNPS_ID;
}
close(IN);

#this function indicates the record delimiter. In this case, an empty line
#as such, it needs to be designated after the other files are processed
$/="";

open(OUT, ">output/load_main_table.sql") || die;
open(PROB, ">output/problem_names_NOHCODE.txt") || die;

#This file is made here and subsequently used by the synonymy script
open(FILE, ">output/accepted_name_list.txt") || die;


#I_common.txt used to be generated from IJM.hash in make_interchange.pl, but this database replaces the IJM.hash.  
#IJM.hash is not longer updated.  This code had to be added here as a replacement.
open(OUT2, ">output/I_common.txt") || die;
		print OUT2 <<EOP;
# Append this (SORTED!) to /cgi-bin/get_cn2.pl. It is the index for common name searches
EOP

open(IN, "input/eflora_treatments.txt") || die;
while(<IN>){
     next if m/^#/; #skip lines that are commented out
     next if m/^Admin/;	#skip lines that start with Admin

++$count_lines;
#replace underscore italics indicators with HTML italics tags. Maybe this should be done in PHP?
	s/_n_/<i>n<\/i>/g;

	s/ _/ <i>/g;
	s/\(_/\(<i>/g;
	s/"_/"<i>/g;
	s/\[_/\[<i>/g;
	s/\/_/\/<i>/g;
	s/,_/,<i>/g;
	s/;_/;<i>/g;
	
	s/_ /<\/i> /g;
	s/_"/<\/i>"/g;
	s/_\]/\]<\/i>/g;
	s/_,/<\/i>,/g;
	s/_\./<\/i>./g;
	s/_\)/<\/i>\)/g;
	s/_;/<\/i>;/g;
	s/_:/<\/i>:/g;
	s/_-/<\/i>-/g;
	s/_\//<\/i>\//g;
	s/_\n/<\/i>\n/g;

#Escaping single quotes for SQL insert
	s/'/''/g;

if(m/([A-Z]+ACEAE)/){ #when it encounters a CAPS string ending in ACEAE
$family=$1; #that word is assigned to $family (until it gets reassigned)
++$fam_lines;
}

#The contents of many tags are retrieved with the generalized "&basic_get" subroutine
	my $plant_body=&basic_get($_, "PLANT BODY");
	my $sterile_stem=&basic_get($_, "STERILE STEM");
	my $fertile_stem=&basic_get($_, "FERTILE STEM");
	my $staminate_head=&basic_get($_, "STAMINATE HEAD");
	my $ray_or_pistillate_flower=&basic_get($_, "RAY OR PISTILLATE FLOWER");
	my $pistillate_head=&basic_get($_, "PISTILLATE HEAD");
	my $staminate_inflorescence=&basic_get($_, "STAMINATE INFLORESCENCE");
	my $pistillate_or_bisexual_inflorescence=&basic_get($_, "PISTILLATE OR BISEXUAL INFLORESCENCE");
	my $pistillate_inflorescence=&basic_get($_, "PISTILLATE INFLORESCENCE");
	my $fertile_spikelet=&basic_get($_, "FERTILE SPIKELET");
	my $sterile_spikelet=&basic_get($_, "STERILE SPIKELET");
	my $distal_spikelet=&basic_get($_, "DISTAL SPIKELET");
	my $central_spikelet=&basic_get($_, "CENTRAL SPIKELET");
	my $lateral_spikelet=&basic_get($_, "LATERAL SPIKELET");
	my $staminate_spikelet=&basic_get($_, "STAMINATE SPIKELET");
	my $pistillate_spikelet=&basic_get($_, "PISTILLATE SPIKELET");
	my $staminate_flower=&basic_get($_, "STAMINATE FLOWER");
	my $pistillate_flower=&basic_get($_, "PISTILLATE FLOWER");
	my $ray_flower=&basic_get($_, "RAY FLOWER");
	my $pollen_cone=&basic_get($_, "POLLEN CONE");
	my $seed_cone=&basic_get($_, "SEED CONE");
	my $bisexual_flower=&basic_get($_, "BISEXUAL FLOWER");
	my $fruit=&basic_get($_, "FRUIT");
	my $seed=&basic_get($_, "SEED");
	my $sporangia=&basic_get($_, "SPORANGIA");
	my $male_sporangium_case=&basic_get($_, "MALE SPORANGIUM CASE");
	my $female_sporangium_case=&basic_get($_, "FEMALE SPORANGIUM CASE");
	my $spores=&basic_get($_, "SPORES");
	my $ecology=&basic_get($_, "ECOLOGY");
	my $elevation=&basic_get($_, "ELEVATION");
	my $toxicity=&basic_get($_, "TOXICITY");
	my $unabridged_reference=&basic_get($_, "UNABRIDGED REFERENCE"); #added August 2017
	my $unabridged_note=&basic_get($_, "UNABRIDGED NOTE");
	my $flowering_time=&basic_get($_, "FLOWERING TIME");
	my $fruiting_time=&basic_get($_, "FRUITING TIME");
	#my $coning_time=&basic_get($_, "CONING TIME");
	my $weediness=&basic_get($_, "WEEDINESS");
	
#The remaining tags have dedicated "&get" subroutines"
	my $taxon_name= &get_taxon_name($_);
	my $taxon_author=&get_taxon_author($_);
	my $common_name=&get_common_name($_);
	my $key_group=&get_key_group($_);
	my $eflora_status=&get_status($_);
	my $TJM2_author=&get_TJM2_author($_);
	my $scientific_editor=&get_scientific_editor($_);
	my $habit=&get_habit($_);
	my $stem=&get_stem($_);
	my $leaf=&get_leaf($_);
	my $spines=&get_spines($_);
	my $inflorescence=&get_inflorescence($_);
	my $spikelet=&get_spikelet($_);
	my $flower=&get_flower($_);
	my $disk_flower=&get_disk_flower($_);
	my $cone=&get_cone($_);
	my $sporangium_case=&get_sporangium_case($_);
	my $chromosomes= &get_chromosomes($_);	

	my $bioregional_distribution=&get_bioregion($_);
	my $outside_CA=&get_outside_CA($_);
	my $species_in_genus=&get_species_in_genus($_);
	my $genera_in_family=&get_genera_in_family($_);
	my $etymology=&get_etymology($_);
	my $synonyms=&get_synonyms($_);
	my $unabridged_synonyms=&get_unab_synonyms($_);
	my $reference=&get_reference($_); #added August 2017
	my $note=&get_note($_);
	my $ft_code=&get_flowering_time_code($_); #fetches the flowering time in the format needed for the "heath bar" display script
	my $is_terminal_taxon=&is_terminal_taxon($_);
	my $revision_number=&get_revision_number($_); #revision number is assigned based on which "TJM# AUTHOR" tags are used
	my $revision_date=&get_revision_date($_); #revision date is assigned based on which "TJM# AUTHOR" tags are used, added Mar2017, JAA

#the $full_formatted_display_name is the full name including authors and italics tags
#this is required since autonyms have their authority inserted after the species
#and infra taxa lacking a species treatment (ILST) need to have the species author included
#for display purposes (but not searching).

#This is tricky because you need to titlecase the genus separately for ILST names
#otherwise the authority gets all lowercased

if ($taxon_name =~ /([A-Z]+) ([a-z-]+)$/){ #if it is an infra with an author inserted (that's the ".+")
	$species_author = $taxon_author;
}

if ($taxon_name =~ m/ENCELIA farinosa A\. Gray ex Torr\. &times; E\. frutescens/){ #the spontaneous hybrid is kluged because there is only one and it's awkward
	$taxon_name = "Encelia farinosa &times; Encelia frutescens";
	$full_formatted_display_name = "<i>Encelia farinosa</i> &times; <i>Encelia frutescens</i>";
}
elsif ($taxon_name =~ /([A-Z]+) ([a-z-]+) (.+) \b(nothosubsp.|subvar.|var\.|subsp\.) ([a-z-]+)$/){ #if it is an infra with an author inserted (that's the ".+")
	$genus = ucfirst(lc($1));
	$species = $2;
	$species_author = $3;
	$infra_rank = $4;
	$infra_epithet = $5;
	$taxon_name=ucfirst(lc($taxon_name));
	$taxon_name=&strip_name($taxon_name);
#print "$taxon_name\n";
	if ($species eq $infra_epithet){ #if it is an autonym, inserted author goes after specific epithet, and there is no $taxon_author, except if we have forma, those should go through strip name below
		$full_formatted_display_name = "<i>$genus $species</i> $species_author $infra_rank <i>$infra_epithet</i>";
	}
	else { #else the inserted author stays after the specific epithet, and the $taxon_author goes at the end
		$full_formatted_display_name = "<i>$genus $species</i> $species_author $infra_rank <i>$infra_epithet</i> $taxon_author";
	}
}
elsif ($taxon_name =~ /([A-Z]+) ([a-z-]+) \b(nothosubsp.|subvar.|var\.|subsp\.) ([a-z-]+)$/){ #if it is an infra without an author in the name, except if we have forma, those should go through strip name below
	$genus = ucfirst(lc($1));
	$species = $2;
	$infra_rank = $3;
	$infra_epithet = $4;
	$taxon_name=ucfirst(lc($taxon_name));
	if ($species eq $infra_epithet){ #if it is an autonym, author goes after specific epithet
		$full_formatted_display_name = "<i>$genus $species</i> $taxon_author $infra_rank <i>$infra_epithet</i>";
	}
	else { #otherwise the author goes at the end
		$full_formatted_display_name = "<i>$genus $species</i> $species_author $infra_rank <i>$infra_epithet</i> $taxon_author";
	}
}
else { #The rest should be family, genus, or binomial species treatments
	$taxon_name=ucfirst(lc($taxon_name));
	$taxon_name=&strip_name($taxon_name);
	if ($taxon_author eq "NULL"){
		$full_formatted_display_name = "<i>$taxon_name</i>";
	}
	else {
		$full_formatted_display_name = "<i>$taxon_name</i> $taxon_author";
	}
}

$family=ucfirst(lc($family));

#Some families have alternate names in parens, e.g. "Asteraceae (Compositae)"
#first, make sure the alternate name is capitalized correctly
if ($taxon_name =~ /([A-Za-z]+) \((.*)\)/){ #can't have the parens as part of $2, otherwise the ucfirst function will target the open paren
	$taxon_name = $1 . " " . "(" . ucfirst($2) . ")"; 
} 
#then before matching to taxon ids, create a name_for_matching that removes the alternate name
$name_for_matching = $taxon_name;

if ($taxon_name =~ m/Encelia farinosa &times; Encelia frutescens/){ #the spontaneous hybrid is kluged because there is only one and it's awkward
	$name_for_matching = "Encelia farinosa X Encelia frutescens";
}
else{
	foreach ($name_for_matching){
		++$NFM;
		s/ \(.*\)//;
		s/&times; ([A-Z])/&times;$1/;
	}

}

$taxon_id=$TNOAN{$name_for_matching};

	if ($name_for_matching =~ m/Encelia farinosa X Encelia frutescens/){ #the spontaneous hybrid is kluged because there is only one and it's awkward
		$taxon_id = "100435";
	}
	
	next unless $taxon_id;
print LOG "$TNOAN{$name_for_matching}\t$name_for_matching\n";

#print out the plain matched taxon names to file used by synonymy script
print FILE "$name_for_matching\n";

	unless ($common_name eq "NULL"){
		my $CN_ALT = $common_name;
		$CN_ALT =~ s/'//g;
		print OUT2 $CN_ALT.": ".$taxon_id."\n";
	}

#test print
#print "$taxon_id\t$taxon_name\t$taxon_author\t$full_formatted_display_name\n";
#print "<tr><td>$taxon_id</td><td>$taxon_name</td><td>$taxon_author</td><td>$full_formatted_display_name</td</tr>\n";

#add single quotes to fields that were used for processing
$taxon_name="\'$taxon_name\'";
$taxon_author="\'$taxon_author\'" unless $taxon_author eq "NULL";
$full_formatted_display_name="\'$full_formatted_display_name\'";

#dist_codes are a shorter hexidecimal representation of a 40-character binary vector
#the 40 character vector indicates the presence or absence of a taxon in a bioregion
#the first 35 represent the 35 bioregions; the last five are blank spots (always 0)
#get_all_dist.pl translates bioregion distribution strings into the binary vector and packs it into hex
#here we unpack the hex so we can also store the binary vector in the database
#the binary is used by the online "checklist builder" pages
#$dist_code=$HEX{$taxon_id};
		#$dist_array = "NULL"; #make all arrays NULL at this step, the original code is not creating them correctly
								#and I am not sure they are needed, as the make_dist file does this step now.

	if ($HEX{$taxon_id}){
		$dist_code=$HEX{$taxon_id};

		$dist_code = &format_for_SQLite($dist_code);


		#$dist_array = unpack("b*",pack("H*",$HEX{$taxon_id}));
		#$dist_array = &format_for_SQLite($dist_array);
	}
#all keys are number now, the old file was a confusing mix of names and taxon ID's
#some coded for the same taxon but had different distributions due to errors in synonymy tables
#	elsif ($HEX{$name_for_matching}){
#		$dist_code=$HEX{$name_for_matching};
#		$dist_code = &format_for_SQLite($dist_code);

#		$dist_array = unpack("b*",pack("H*",$HEX{$name_for_matching}));
#		$dist_array = &format_for_SQLite($dist_array);
#	}
	else{
		#$dist_array = "NULL";
		$dist_code = "NULL";
		++$DIST_NULL;
		unless ($name_for_matching =~ m/^([A-Z][a-z-]+|[A-Z][a-z]+aceae)$/){
			print PROB "HCODE PROBLEM: $name_for_matching==>$taxon_id\n";
		}
	}
#this file used to use the IJM_key.has file to determine if there is a key
#if($IJM_key{$taxon_id}){
#	$has_key="1";
#}
#else{
#	$has_key="NULL";
#}

#this process has been retired in favor of the method used in the key table
#the presence of a $taxon_id at the beginning of a line is used to determine whether there is a key or not
if($KEYTABLE{$taxon_id}){
	$has_key="1";
}
else{
	$has_key="NULL";
}



#rarity must be fetched last because it needs the $name_for_matching
	$rarity_status= &get_rarity($_);

if($rarity_status !~ m/NULL/){
	++$rare;
}

#print "$taxon_name\t$has_key\n";
#print "$name\t$family\t$bioregion\t$elev\t$ecol\t$flow_per\t$outside_CA\n";
#print "$family\t$name\t$common_name\t$eflora_status\t$rarity\t$weediness\t$bioregion\n";
#print "$inflorescence\n"
#print join("\t",$name,@hv[0 .. 34]), "\n";
#print "$taxon_id\t$taxon_name\t$taxon_author\t$common_name\t$eflora_status\t$TJM2_author\t$habit\t$plant_body\t$stem\t$sterile_stem\t$fertile_stem\t$leaf\t$spines\t$inflorescence\t$staminate_head\t$ray_or_pistillate_flower\t$pistillate_head\t$staminate_inflorescence\t$pistillate_or_bisexual_inflorescence\t$pistillate_inflorescence\t$spikelet\t$fertile_spikelet\t$sterile_spikelet\t$distal_spikelet\t$central_spikelet\t$lateral_spikelet\t$staminate_spikelet\t$pistillate_spikelet\t$flower\t$staminate_flower\t$pistillate_flower\t$ray_flower\t$disk_flower\t$cone\t$pollen_cone\t$seed_cone\t$bisexual_flower\t$fruit\t$seed\t$sporangia\t$sporangium_case\t$male_sporangium_case\t$female_sporangium_case\t$spores\t$chromosomes\t$ecology\t$rarity_status\t$elevation\t$bioregional_distribution\t$outside_CA\t$species_in_genus\t$genera_in_family\t$etymology\t$toxicity\t$synonyms\t$unabridged_synonyms\t$note\t$unabridged_note\t$flowering_time\t$fruiting_time\t$coning_time\t$weediness\t$is_terminal_taxon\t$has_key, $revision_number, $dist_code\n";
#print "$taxon_name\t$taxon_id\n";
#print "$taxon_name\t$common_name\t$taxon_author\t$key_group\n";
#print "$taxon_name\t$taxon_id\t$dist_code\n";
#print "$taxon_id\t$bioregional_distribution\t$dist_code\t$dist_array\n";
#print "$taxon_id\t$taxon_name\t$full_formatted_display_name\n";
#print "$taxon_id\t$taxon_name\t$taxon_author\t$is_terminal_taxon\n";
++$count;
print OUT "INSERT INTO eflora_taxa(TaxonID, ScientificName, TaxonAuthor, FormattedDisplayName, CommonName, KeyGroup, Status, TJM2Author, ScientificEditor, Habit, PlantBody, Stem, SterileStem, FertileStem, Leaf, Spines, Inflorescence, StaminateHead, RayOrPistillateFlower, PistillateHead, StaminateInflorescence, PistillateOrBisexualInflorescence, PistillateInflorescence, Spikelet, FertileSpikelet, SterileSpikelet, DistalSpikelet, CentralSpikelet, LateralSpikelet, StaminateSpikelet, PistillateSpikelet, Flower, StaminateFlower, PistillateFlower, RayFlower, DiskFlower, Cone, PollenCone, SeedCone, BisexualFlower, Fruit, Seed, Sporangia, SporangiumCase, MaleSporangiumCase, FemaleSporangiumCase, Spores, Chromosomes, Ecology, RarityStatus, Elevation, BioregionalDistribution, OutsideCA, SpeciesInGenus, GeneraInFamily, Etymology, Toxicity, Synonyms, UnabridgedSynonyms, Reference, UnabridgedReference, Note, UnabridgedNote, FloweringTime, FloweringTimeCode, FruitingTime, Weediness, IsTerminalTaxon, HasKey, RevisionNumber, RevisionDate, DistCode)\n";
print OUT "VALUES($taxon_id, $taxon_name, $taxon_author, $full_formatted_display_name, $common_name, $key_group, $eflora_status, $TJM2_author, $scientific_editor, $habit, $plant_body, $stem, $sterile_stem, $fertile_stem, $leaf, $spines, $inflorescence, $staminate_head, $ray_or_pistillate_flower, $pistillate_head, $staminate_inflorescence, $pistillate_or_bisexual_inflorescence, $pistillate_inflorescence, $spikelet, $fertile_spikelet, $sterile_spikelet, $distal_spikelet, $central_spikelet, $lateral_spikelet, $staminate_spikelet, $pistillate_spikelet, $flower, $staminate_flower, $pistillate_flower, $ray_flower, $disk_flower, $cone, $pollen_cone, $seed_cone, $bisexual_flower, $fruit, $seed, $sporangia, $sporangium_case, $male_sporangium_case, $female_sporangium_case, $spores, $chromosomes, $ecology, $rarity_status, $elevation, $bioregional_distribution, $outside_CA, $species_in_genus, $genera_in_family, $etymology, $toxicity, $synonyms, $unabridged_synonyms, $reference, $unabridged_reference, $note, $unabridged_note, $flowering_time, $ft_code, $fruiting_time, $weediness, $is_terminal_taxon, $has_key, $revision_number, $revision_date, $dist_code)\n";
print OUT ";\n";
}


print LOG <<EOP;
BEGIN EFLORA MAIN STATS

TOTAL lines in eflora_treatments: $count_lines

Family line count: $fam_lines
Name For Matching count: $NFM
Records added to eflora MAIN: $count

Records with rarity status: $rare

Taxa with no DIST CODE: $DIST_NULL

END EFLORA MAIN STATS
EOP

print <<EOP;
TOTAL lines in eflora_treatments: $count_lines

Family line count: $fam_lines
Name For Matching count: $NFM
Records added to eflora MAIN: $count

END EFLORA MAIN STATS
EOP


close (OUT2);
close (FILE);
close (PROB);
close (OUT);
close (IN);

###########################################

sub format_for_SQLite {
	#given exactly one variable
	#if the variable has contents, put single quotes around the string
	#else, return "NULL" without quotes
	my ($input) = @_;
	if ($input){
		return "\'$input\'";
	}
	else {
		return "NULL";
	}
}

sub basic_get {
	#for tags that don't require any special processing
	#the following basic formula is used
	#given the tage name as a second variable
	my($paragraph, $tag) = @_;
	if($paragraph =~ /$tag: *(.*)/){
		return "\'$1\'";
	}
	else {
		return "NULL";
	}
}

sub get_taxon_name {
    my $par = shift; #each paragraph is separated by a blank line
    @lines=split(/\n/,$par); #the array of lines within a paragraph are values separated by a new line
	if($lines[1]=~/^(POSSIBLY IN CA|CULTIVATED PLANT|WAIF|EXTIRPATED ALIEN|EXTIRPATED WAIF|EXTIRPATED WEED|EXTIRPATED|HISTORICAL WAIF|SPONTANEOUS HYBRID|AGRICULTURAL WEED|GARDEN WEED|URBAN WEED|GARDEN AND URBAN WEED|AGRICULTURAL, GARDEN, OR URBAN WEED|URBAN WEED EXPECTED IN WILDLANDS)/){
        return $lines[2]; #elsif the second line starts with any of the above values, the name is what's on the third line
		#ASCLEPIAS curassavica is also an anomaly here as Line 0 is UNABRIDGED and Line 1 CULTIVATED PLANT
		#this was also not parsing correctly in the old way
    }
    elsif( $lines[0]=~/^WAIF/){ #if the first line starts with...
        return $lines[1]; #the name is what's on the second line
    }
    elsif( $lines[0]=~/^(NATIVE|NATURALIZED)/){ #if the first line starts with...
        return $lines[1]; #the name is the contents of the second line
        #The name for Zeltnera arizonica is on line 2, Line 0 is NATIVE and line 1 is EXTIRPATED
        #in the old code, this was first as 'if', but Zeltnera arizonica was always and error, 
        #since line 1 is not the name
    }
    elsif($lines[0]=~/UNABRIDGED/){ #elsif the first line starts with "UNABRIDGED"
        return $lines[1]; #the name is what's on the second line
    }
    elsif( $lines[0]=~/^[A-Z][A-Z][A-Z]/){ #elsif the first line starts with three capital letters...
        return $lines[0] #the name is what's on the first line
    }
    else{ #otherwise...
        return "NULL"; #don't return anything for that paragraph
    }
}

sub get_taxon_author {
# taxon author is returned without single quotes, since it is used to generate the formatted display name
# single quotes are added later in the script
		my $par = shift;
		if($par=~/TAXON AUTHOR: *\n/){
			return "NULL";
		}
		elsif ($par=~/TAXON AUTHOR: *(.*) (\(Group.*\))/){
			return "$1";
		}
		elsif($par=~/TAXON AUTHOR: *(.*)/){
			return "$1";
		}
		else{
		return "NULL";
		}
}

sub get_common_name {
		my $par = shift;
		
		if($par=~/COMMON NAME: *(.*)\nUNABRIDGED COMMON NAME: *(.*)/){
			return "\'$1; $2\'";
		}
		
		elsif($par=~/COMMON NAME: *(.*) (\(Group.*\))/){
			return "\'$1\'";
		}
		
		elsif($par=~/COMMON NAME: *(.*)/){
			return "\'$1\'";
		}
		else{
		return "NULL";
		}
}

sub get_key_group { #Key Group comes at the end of the common name. If no common name, it's at the end of the taxon author
	my $par = shift;
	if($par=~/COMMON NAME: *(.*) \((Group.*)\)/){
			return "\'$2\'";
		}
	elsif($par=~/TAXON AUTHOR: *(.*) \((Group.*)\)/){
			return "\'$2\'";
		}
	else{
		return "NULL";
	}
}

sub get_status {
    my $par = shift; #each paragraph is separated by a blank line
    @lines=split(/\n/,$par); #the array of lines within a paragraph are values separated by a new line
    if( $lines[0]=~/^(NATIVE|NATURALIZED)/){ #if the first line starts with...
        return "\'$lines[0]\'"; #the name is the contents of the second line
    }
    elsif( $lines[0]=~/^WAIF/){ #if the first line starts with...
        return "\'$lines[0]\'"; #the name is what's on the second line
    }
    elsif($lines[1]=~/^(POSSIBLY IN CA|WAIF|EXTIRPATED ALIEN|EXTIRPATED WAIF|EXTIRPATED WEED|EXTIRPATED|HISTORICAL WAIF|SPONTANEOUS HYBRID|AGRICULTURAL WEED|GARDEN WEED|URBAN WEED|GARDEN AND URBAN WEED|AGRICULTURAL, GARDEN, OR URBAN WEED|URBAN WEED EXPECTED IN WILDLANDS)/){
        return "\'$lines[1]\'"; 
	}
    else {
    	return "NULL";
    }
}


sub get_scientific_editor {
		my $par = shift;
		if($par =~ /SCIED: Scientific Editors?: *(.+)/){
			return "\'$1\'";
		}
		else{
			return "NULL";
		}	
}

sub get_habit {
		my $par = shift;
		if($par=~/HABIT\+: *\n/){ #The HABIT+ tag is always included, even if empty
			return "NULL";
		}
		elsif($par=~/HABIT\+: *(.*)/){
			return "\'$1\'";
		}
		else{
			return "NULL";
		}
}

sub get_stem {
		my $par = shift;
		if($par =~ /([\H])STEM: *(.*)/){
			return "\'$2\'";
		}
		elsif($par =~ /STEMS: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_leaf {
		my $par = shift;
		if($par =~ /LEAF: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /LEAVES: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_spines {
		my $par = shift;
		if($par =~ /SPINES: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /SPINE: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_inflorescence {
		my $par = shift;
		if($par =~ /([\H])INFLORESCENCE: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_spikelet {
		my $par = shift;
		if($par =~ /([\H])SPIKELET: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_flower {
		my $par = shift;
		if($par =~ /UNABRIDGED FLOWER: *(.*)/){ #there is only one unabridged flower line as of 2017, do not need combined list
			return "\'$1\'";
		}
		elsif($par =~ /([\H])FLOWER: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_disk_flower {
		my $par = shift;
		if($par =~ /([\H])DISK FLOWER: *(.*)\nUNABRIDGED DISK FLOWER: *(.*)/){
			return "\'$2; $3\'";
		}
		elsif($par =~/([\H])DISK FLOWER: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_cone {
		my $par = shift;
		if($par =~ /([\H])CONE: *(.*)/){
			return "\'$2\'";
		}
		elsif($par =~ /CONES: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_sporangium_case {
		my $par = shift;
		if($par =~ /SPORANGIUM CASE: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /SPORANGIUM CASES: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_chromosomes {
		my $par = shift;
		if($par =~ /UNABRIDGED CHROMOSOMES: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /([\H])CHROMOSOMES: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_rarity {
#This stores the CNPS database ID for records with rarity status
#or if the ID is not available, the search terms to put in the CNPS search URL
		my $par = shift;
		if($par=~/RARITY STATUS: *(.*)/){
			if ($CNPS{$name_for_matching}) {
				return "\'$CNPS{$name_for_matching}\'";
			}
			else {
				$name_for_matching=~s/ subsp\. / ssp. /;
				$name_for_matching=~s/ /\+/;
				return "\'$name_for_matching\'";
			}
		}
		else{
		return "NULL";
			}
}

sub get_bioregion {
		my $par = shift;
		if($par=~/UNABRIDGED BIOREGIONAL DISTRIBUTION: *(.*)/){ 
		#select unabridged distribution line when present, theoretically this should have everything that the normal BIO DIST line has
		#there is currently only one case of this and it has same regions on both lines
			return "\'$1\'";
		}
		elsif($par=~/BIOREGIONAL DISTRIBUTION: *(.*)/){
			return "\'$1\'";
		}
		else{
		return "NULL";
		}
}

sub get_outside_CA {
		my $par = shift;
        if($par=~ m/UNABRIDGED DISTRIBUTION OUTSIDE CALIFORNIA: *(.*)/){
                return "\'$1\'";
        }
        elsif($par=~ m/DISTRIBUTION OUTSIDE CALIFORNIA: *(.*)/){
                return "\'$1\'";
        }
        else{
                return "NULL";
        }
}

sub get_species_in_genus {
		my $par = shift;
		if($par =~ /UNABRIDGED SPECIES IN GENUS: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /SPECIES IN GENUS: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_genera_in_family {
		my $par = shift;
		if($par =~ /UNABRIDGED GENERA IN FAMILY: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /GENERA IN FAMILY: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_etymology {
		my $par = shift;
		if($par =~ /UNABRIDGED ETYMOLOGY: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /ETYMOLOGY: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_synonyms {
		my $par = shift;
		if($par=~/([\H])SYNONYMS: *(.*)\n/){
			return "\'$2\'";
		}
		else{
		return "NULL";
		}

}

sub get_unab_synonyms {
		my $par = shift;
		if($par=~/([\H])UNABRIDGED SYNONYMS: *(.*)\n/){
			return "\'$2\'";
		}
		else{
		return "NULL";
		}
}


sub get_reference {
		my $par = shift;
		if($par =~ /([\H])REFERENCE: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_note {
		my $par = shift;
		if($par =~ /([\H])NOTE: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_flowering_time_code {
        my $entry = shift;
        undef @FT; 
        my @FT; #This needs to be done outside the loops, otherwise in cases where there are multiple ranges, the array will be overwritten
        if($entry=~/([A-Z][a-z][a-z])\??--([A-Z][a-z][a-z])/){ #searches the whole entry for ranges, because e.g. Coning time is recorded in the NOTES field
        	%monthno=("Jan",0,"Feb",1,"Mar",2,"Apr",3,"May",4,"Jun",5,"Jul",6,"Aug",7,"Sep",8,"Oct",9,"Nov",10,"Dec",11); #heath bar index starts at 0
            if($monthno{$1} > $monthno{$2}){
                foreach $no (0 .. $monthno{$2}){
                    push @FT, $no; 
                }
                foreach $no ($monthno{$1} .. 11){
                    push @FT, $no;
                }
            }
            else{
                foreach $no ($monthno{$1} .. $monthno{$2}){
                	push @FT, $no;
                }      
            }
            $FTCODE = join (",", @FT);
        	return "\'$FTCODE\'"; 
        }
#single month flowering times are rare, but present.  This part fixes the original code which ignored single month dates
		elsif($entry =~ /([\H])FLOWERING TIME: *([A-Z][a-z][a-z])([\H])/){
        	%monthno=("Jan",0,"Feb",1,"Mar",2,"Apr",3,"May",4,"Jun",5,"Jul",6,"Aug",7,"Sep",8,"Oct",9,"Nov",10,"Dec",11); #heath bar index starts at 0
			$no = $monthno{$2};
        	return "\'$no\'"; 
		}
		elsif($entry =~ /([\H])FLOWERING TIME: *\+?-? *(All year)/){
        	return "\'0,1,2,3,4,5,6,7,8,9,10,11\'"; 
		}
#there are other variants being missed by this script.  they need to be added here
        else{
            return "NULL";
        }
}

sub is_terminal_taxon {
        my $par = shift;
		if ($par=~ m/BIOREGIONAL DISTR/){
        	return 1;
        }
		else{
			return "NULL";
		}
}

sub get_TJM2_author {
		my $par = shift;
		if($par =~ /TJM9X AUTHOR: *(.+)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJM8X AUTHOR: *(.+)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJM7X AUTHOR: *(.+)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJM6X AUTHOR: *(.+)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJM5X AUTHOR: *(.+)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJM4X AUTHOR: *(.+)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJMXXX AUTHOR: *(.+)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJMXX AUTHOR: *(.+)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJMX AUTHOR: *(.+)/){
			return "\'$1\'";
		}
		elsif($par =~/TJM2 AUTHOR: *(.+)/){
			return "\'$1\'";
		}
		else{
			return "NULL";
		}
}


sub get_revision_number {
	my $par = shift;
	if ($par =~ m/TJM9X AUTHOR:/){
		return "\'Revision 9\'";
	}
	elsif ($par =~ m/TJM8X AUTHOR:/){
		return "\'Revision 8\'";
	}
	elsif ($par =~ m/TJM7X AUTHOR:/){
		return "\'Revision 7\'";
	}
	elsif ($par =~ m/TJM6X AUTHOR:/){
		return "\'Revision 6\'";
	}
	elsif ($par =~ m/TJM5X AUTHOR:/){
		return "\'Revision 5\'";
	}
	elsif ($par =~ m/TJM4X AUTHOR:/){
		return "\'Revision 4\'";
	}
	elsif ($par =~ m/TJMXXX AUTHOR:/){
		return "\'Revision 3\'";
	}
	elsif ($par =~ m/TJMXX AUTHOR:/){
		return "\'Revision 2\'";
	}
	elsif ($par =~ m/TJMX AUTHOR:/){
		return "\'Revision 1\'";
	}
	else {
		return "NULL";
	}
}

sub get_revision_date {
	my $par = shift;
	if ($par =~ m/TJM9X AUTHOR: .*/){
		return "\'2021\'";
	}
	elsif ($par =~ m/TJM8X AUTHOR: .*/){
		return "\'2020\'";
	}
	elsif ($par =~ m/TJM7X AUTHOR: .*/){
		return "\'2019\'";
	}
	elsif ($par =~ m/TJM6X AUTHOR: .*/){
		return "\'2018\'";
	}
	elsif ($par =~ m/TJM5X AUTHOR: .*/){
		return "\'2017\'";
	}
	elsif ($par =~ m/TJM4X AUTHOR: .*/){
		return "\'2016\'";
	}
	elsif ($par =~ m/TJMXXX AUTHOR: .*/){
		return "\'2015\'";
	}
	elsif ($par =~ m/TJMXX AUTHOR: .*/){
		return "\'2014\'";
	}
	elsif ($par =~ m/TJMX AUTHOR: .*/){
		return "\'2013\'";
	}
	elsif ($par =~ m/TJM2 AUTHOR: .*/){
		return "\'2012\'";
	}
	else {
		return "NULL";
	}
}


sub strip_name{
local($_) = @_;

s/"//g;
$_=ucfirst($_);

s/  +/ /g;
s/^ +//;
s/ +$//;

#encelioides (Cav.) Benth. & Hook. f. ex A. Gray subsp. exauriculata
s/Hook\. f\. ex A\. Gray/Hook. filius ex A. Gray/i;

#add additional 'filial' authorities at this point so they parse correctly, JAA
s/Ait\. f\./Ait. filius/g;
s/Backh\. f\./Backh. filius/g;
s/Baker f\./Baker filius/g;
s/Bakh\. f\./Bakh. filius/g;
s/Balf\. f\./Balf. filius/g;
s/Burm\. f\./Burm. filius/g;
s/Brunner,? f\./Brunner filius/g;
s/Celakovsky f\./L.F. Celak./g;
s/Delar\. f\./Delar. filius/g;
s/Forst\. f\./Forst. filius/g;
s/Gaertn\. f\./Gaertn. filius/g;
s/Gagnaire f\./Gagnaire filius/g;
s/Haage f\./Haage filius/g;
s/Haller f\./Haller filius/g;
s/Hallier f\./Hallier filius/g;
s/Harr\. f\./Harr. filius/g;
s/Hedw\. f\./Hedw. filius/g;
s/Hirats\. f\./Hirats. filius/g;
s/Hook\. f\./Hook. filius/g;
s/Hooker f\./Hooker filius/g; #some people dont abbreviate Hooker
s/Jacq\. f\./Jacq. filius/g;
s/Kickx f\./Kickx filius/g;
s/Kampm\. f\./Kampm. filius/g;
s/Keng f\./Keng filius/g;
s/Klokov f\./Klokov filius/g;
#s/L\. f\. sulcat/f. sulcat/g;

s/L\. f\. var./L. filius var./g;
s/L\. f\. subsp./L. filius subsp./g;
s/L\. f\./L. filius/g;
s/L\. *filius azure/L. f. azure/g; #fix special cases where L. f. is a forma name not filius, Anagallis arvensis L. f. azurea Hyl.
s/L\. *filius vine/L. f. vine/g; #fix special cases where L. f. is a forma name not filius, Allium vineale L. f. vineale
s/L\. *filius comp/L. f. comp/g; #fix special cases where L. f. is a forma name not filius, Allium vineale L. f. compactum L.
s/L\. *filius tome/L. f. tome/g; #fix special cases where L. f. is a forma name not filius, Acer rubrum L. f. tomemtosum L. 
s/L\. *filius sang/L. f. sang/g; #fix special cases where L. f. is a forma name not filius, Acer negundo L. f. sanguineum L. Martin
s/L\. *filius masc/L. f. masc/g; #fix special cases where L. f. is a forma name not filius, Orchis morio L. f. mascula L.
s/L\. *filius lute/L. f. lute/g; #fix special cases where L. f. is a forma name not filius, Ophrys insectifera L. f. luteomarginata L. Lewis
s/L\. *filius micr/L. f. micr/g; #fix special cases where L. f. is a forma name not filius, Jasminum humile L. f. microphyllum L.C. Chia
s/L\. *filius sask/L. f. sask/g; #fix special cases where L. f. is a forma name not filius, Carex capillaris L. f. saskatschewana (Boeckeler) L.H. Bailey
s/L\. *filius negl/L. f. negl/g; #fix special cases where L. f. is a forma name not filius, Celtis occidentalis L. f. neglecta L.
s/L\. *filius duri/L. f. duri/g; #fix special cases where L. f. is a forma name not filius, Eryngium campestre L. f. duriberum L.
s/L\. *filius glab/L. f. glab/g; #fix special cases where L. f. is a forma name not filius, Dioscorea villosa L. f. glabrata L.
s/L\. *filius prae/L. f. prae/g; #fix special cases where L. f. is a forma name not filius, Silphium trifoliatum L. f. praecisum L.M. Perry
s/L\. *filius pinn/L. f. pinn/g; #fix special cases where L. f. is a forma name not filius, Quercus alba L. f. pinntifida L.
s/L\. *filius sulc/L. f. sulc/g; #fix special cases where L. f. is a forma name not filius, Zostera marina L. f. sulcatifolia Setchell
s/L\. *filius pinn/L. f. vill/g; #fix special cases where L. f. is a forma name not filius, Cardiospermum corindum L. f. villosum (Mill.) Radlk
s/Lestib\. f\./Lestib. filius/g;
s/Lindb\. f\./Lindb. filius/g;
s/Lindm\. f\./Lindm. filius/g;
s/Luer f\./Luer filius/g;
s/Michx\. f\./F. Michx./g;
s/Michaux f\./F. Michx./g;
s/Occhioni f\./Occhioni filius/g;
s/Pearsall f\./Pearsall filius/g;
s/Phil\. f\./Phil. filius/g;
s/Rchb\. f\./Rchb. filius/g;
s/Rech\. f\./Rech. filius/g;
s/Rehb\. f\./Rehb. filius/g;
s/Reichenb\. f\./Reichenb. filius/g;
s/Reichenbach f\./Reichenbach filius/g;
s/Scheuchzer f\./Scheuchzer filius/g;
s/Schultes f\./Schultes filius/g;
s/Schult\. f\./Schult. filius/g;
s/Wallr\. f\./Wallr. filius/g;
s/Wendl\. f\./Wendl. filius/g;



s/,//g; #delete stray commas
s/^([A-Z][A-Za-z-]+) (\b[-a-z]+) [\w&;'().\- ]+ (\bsubvar\.|\bsubsp\.|\bvar\.|\bf\.|\bnothosubsp\.) (\b[a-z-]+) [\w&;'().\- ]+/$1 $2 $3 $4/ ||
s/^([A-Z][A-Za-z-]+) (\b[-a-z]+) [\w&;'().\- ]+ (\bsubvar\.|\bsubsp\.|\bvar\.|\bf\.|\bnothosubsp\.) ([-a-z]+)/$1 $2 $3 $4/ ||
s/^([A-Z][A-Za-z-]+) (\b[-a-z]+) (\bsubvar\.|\bsubsp\.|\bvar\.|\bf\.|\bnothosubsp\.) ([-a-z]+) [\w&;'().\- ]+/$1 $2 $3 $4/ ||
s/^([A-Z][A-Za-z-]+) (\b[-a-z]+) (\bsubvar\.|\bsubsp\.|\bvar\.|\bf\.|\bnothosubsp\.) ([-a-z]+)/$1 $2 $3 $4/ ||
s/^([A-Z][A-Za-z-]+) (\b&times;)([-a-z]+) [\w&;'().\- ]+/$1 $2$3/||
s/^([A-Z][A-Za-z-]+) (\b&times;)([-a-z]+)/$1 $2$3/||
s/^([A-Z][A-Za-z-]+) (\b[-a-z]+) [\w&;'().\- ]+/$1 $2/||
s/^([A-Z][A-Za-z-]+) (\b[-a-z]+)/$1 $2/||
s/^(&times;)([A-Z]?[A-Za-z-]+) (\b[-a-z]+) [\w&;'().\- ]+/$1$2 $3/||
s/^(&times;)([A-Z]?[A-Za-z-]+) (\b[-a-z]+)/$1$2 $3/;
s/ +/ /;
s/ +$//;
s/^ +//;


#s/^([A-Z][A-Za-z-]+) ([-a-z]+) ?.* (subvar\.|subsp\.|var\.|f\.|nothosubsp\.) ([-a-z]+).*/$1 $2 $3 $4/ ||
#s/^([A-Z][A-Za-z-]+) (&times;)([-a-z]+) .+/$1 $2$3/||
#s/^([A-Z][A-Za-z-]+) (&times;)([-a-z]+)/$1 $2$3/||
#s/^([A-Z][A-Za-z-]+) (&times;) ([-a-z]+) .+/$1 $2$3/||
#s/^([A-Z][A-Za-z-]+) (&times;) ([-a-z]+)/$1 $2$3/||
#s/^([A-Z][A-Za-z-]+) ([-a-z]+) .+/$1 $2/||
#s/^([A-Z][A-Za-z-]+) ([-a-z]+)/$1 $2/||
#s/^(&times;)([A-Z][a-z-]+) ([-a-z]+) (.+)/$1$2 $3/||
#s/^(&times;)([A-Z][a-z-]+) ([-a-z]+)/$1$2 $3/;
#s/  +/ /;
#s/^ +//;
#s/ +$//;


#print "$_ \n";
$_;
}