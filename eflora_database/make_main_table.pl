#In all cases where the 'sub get_taxon_name' is present in the eflora, Zeltnera arizonica fails to parse, including the custom parsing scripts.
#Zeltnera arizonica is a native that is extirpated.  It is not parsing into the index or onto species pages in the flora.  This code below does not accept this format:
#NATIVE
#EXTIRPATED
#ZELTNERA arizonica
#TAXON AUTHOR: (A. Gray) G. Mans.
#Native species check for Native on line 0 and report the name on line 1, this is skipping the taxon name in this case.
#It is the only extirpated native in the eflora as of 2017, the others are unabridged and they are catgorized as 'WEED' or 'ALIEN'.

#use lib "/JEPS-master/Jepson-eFlora/Modules/";
use BerkeleyDB::Hash;
use warnings;
use strict;
use BerkeleyDB;
use lib '/Users/davidbaxter/DATA';
use CCH;
use flatten;


my $smasch_code;
my $smasch_name;
my @residue;
my %TNOAN;
my %IJM_key;
my $hex_code;
my $hex_ID;
my $HEX = "";
my %HEX;
my $CNPS_ID;
my $CNPS_name;
my %CNPS;
my $full_formatted_display_name;
my $genus;
my $species;
my $species_author;
my $infra_rank;
my $infra_epithet;
my $name_for_matching;
my $family;
my $dist_code;
my $taxon_id;
my $dist_array;
my $has_key;
my $rarity_status;
my @lines;
my @FT;
my %monthno;
my $no;
my $FTCODE;




open(IN, "/Users/davidbaxter/DATA/smasch_taxon_ids.txt") || die;
while(<IN>){
	chomp;
	s/X /&times;/;
	($smasch_code,$smasch_name,@residue)=split(/\t/);
	$TNOAN{$smasch_name}=$smasch_code;
	#$TID{$smasch_code}=$smasch_name;
}
close(IN);

#use the key hash from Dick's version of the eflora to determine whether or not there is a key
#this is stored as "1 or Null" in Baxter's eflora taxon table in the field "HasKey"
#DB note: I am sure there's a better way to do it once the key is actually stored in the database 
tie(%IJM_key, "BerkeleyDB::Hash", -Filename=>"/Users/davidbaxter/DATA/eFlora/IJM_key.hash", -Flags      => BerkeleyDB::DB_CREATE )|| die "Stopped; couldnt open IJM_key\n";

#process the bioregion hex code file, generated by get_all_dist.pl
open(IN, "outputs/tid_HCODE_cch_out.txt") || die;
while(<IN>){
	$hex_code="";
	chomp;
	($hex_ID, $hex_code) = split(/\t/);
	$HEX{$hex_ID} = $hex_code;
}
close(IN);

#store the CNPS_ID field in a hash
open(IN, "/Users/davidbaxter/DATA/Interchange/CNPS_ID.txt") || die;
while(<IN>){
	$CNPS_ID="";
	$CNPS_name="";
	chomp;

	($CNPS_ID,
	$CNPS_name) = split(/\t/);
	
	foreach($CNPS_name){
		s/ ssp\. / subsp. /;
	}
	
	$CNPS{$CNPS_name} = $CNPS_ID;
}
close(IN);

#this function indicates the record delimiter. In this case, an empty line
#as such, it needs to be designated after the other files are processed
$/="";

open(OUT, ">outputs/load_main_table.sql") || die;

#This file is made here and subsequently used by the synonymy script
open(FILE, ">outputs/accepted_name_list.txt") || die;

open(IN, "eflora_treatments.txt") || die;
while(<IN>){
     next if m/^#/; #skip lines that are commented out
     next if m/^Admin/;	#skip lines that start with Admin

#replace underscore italics indicators with HTML italics tags. Maybe this should be done in PHP?
	s/_n_/<i>n<\/i>/g;

	s/ _/ <i>/g;
	s/\(_/\(<i>/g;
	s/"_/"<i>/g;
	s/\[_/\[<i>/g;
	s/\/_/\/<i>/g;
	s/,_/,<i>/g;
	s/;_/;<i>/g;
	
	s/_ /<\/i> /g;
	s/_"/<\/i>"/g;
	s/_\]/\]<\/i>/g;
	s/_,/<\/i>,/g;
	s/_\./<\/i>./g;
	s/_\)/<\/i>\)/g;
	s/_;/<\/i>;/g;
	s/_:/<\/i>:/g;
	s/_-/<\/i>-/g;
	s/_\//<\/i>\//g;
	s/_\n/<\/i>\n/g;

#Escaping single quotes for SQL insert
	s/'/''/g;

if(m/([A-Z]+ACEAE)/){ #when it encounters a CAPS string ending in ACEAE
$family=$1; #that word is assigned to $family (until it gets reassigned)
}

#The contents of many tags are retrieved with the generalized "&basic_get" subroutine
	my $plant_body=&basic_get($_, "PLANT BODY");
	my $sterile_stem=&basic_get($_, "STERILE STEM");
	my $fertile_stem=&basic_get($_, "FERTILE STEM");
	my $staminate_head=&basic_get($_, "STAMINATE HEAD");
	my $ray_or_pistillate_flower=&basic_get($_, "RAY OR PISTILLATE FLOWER");
	my $pistillate_head=&basic_get($_, "PISTILLATE HEAD");
	my $staminate_inflorescence=&basic_get($_, "STAMINATE INFLORESCENCE");
	my $pistillate_or_bisexual_inflorescence=&basic_get($_, "PISTILLATE OR BISEXUAL INFLORESCENCE");
	my $pistillate_inflorescence=&basic_get($_, "PISTILLATE INFLORESCENCE");
	my $fertile_spikelet=&basic_get($_, "FERTILE SPIKELET");
	my $sterile_spikelet=&basic_get($_, "STERILE SPIKELET");
	my $distal_spikelet=&basic_get($_, "DISTAL SPIKELET");
	my $central_spikelet=&basic_get($_, "CENTRAL SPIKELET");
	my $lateral_spikelet=&basic_get($_, "LATERAL SPIKELET");
	my $staminate_spikelet=&basic_get($_, "STAMINATE SPIKELET");
	my $pistillate_spikelet=&basic_get($_, "PISTILLATE SPIKELET");
	my $staminate_flower=&basic_get($_, "STAMINATE FLOWER");
	my $pistillate_flower=&basic_get($_, "PISTILLATE FLOWER");
	my $ray_flower=&basic_get($_, "RAY FLOWER");
	my $pollen_cone=&basic_get($_, "POLLEN CONE");
	my $seed_cone=&basic_get($_, "SEED CONE");
	my $bisexual_flower=&basic_get($_, "BISEXUAL FLOWER");
	my $fruit=&basic_get($_, "FRUIT");
	my $seed=&basic_get($_, "SEED");
	my $sporangia=&basic_get($_, "SPORANGIA");
	my $male_sporangium_case=&basic_get($_, "MALE SPORANGIUM CASE");
	my $female_sporangium_case=&basic_get($_, "FEMALE SPORANGIUM CASE");
	my $spores=&basic_get($_, "SPORES");
	my $ecology=&basic_get($_, "ECOLOGY");
	my $elevation=&basic_get($_, "ELEVATION");
	my $toxicity=&basic_get($_, "TOXICITY");
	my $unabridged_synonyms=&basic_get($_, "UNABRIDGED SYNONYMS");
	my $unabridged_reference=&basic_get($_, "UNABRIDGED REFERENCE"); #added August 2017
	my $unabridged_note=&basic_get($_, "UNABRIDGED NOTE");
	my $flowering_time=&basic_get($_, "FLOWERING TIME");
	my $fruiting_time=&basic_get($_, "FRUITING TIME");
	my $coning_time=&basic_get($_, "CONING TIME");
	my $weediness=&basic_get($_, "WEEDINESS");
	
#The remaining tags have dedicated "&get" subroutines"
	my $taxon_name= &get_taxon_name($_);
	my $taxon_author=&get_taxon_author($_);
	my $common_name=&get_common_name($_);
	my $key_group=&get_key_group($_);
	my $native_status=&get_native_status($_);
	my $TJM2_author=&get_TJM2_author($_);
	my $scientific_editor=&get_scientific_editor($_);
	my $habit=&get_habit($_);
	my $stem=&get_stem($_);
	my $leaf=&get_leaf($_);
	my $spines=&get_spines($_);
	my $inflorescence=&get_inflorescence($_);
	my $spikelet=&get_spikelet($_);
	my $flower=&get_flower($_);
	my $disk_flower=&get_disk_flower($_);
	my $cone=&get_cone($_);
	my $sporangium_case=&get_sporangium_case($_);
	my $chromosomes= &get_chromosomes($_);	

	my $bioregional_distribution=&get_bioregion($_);
	my $outside_CA=&get_outside_CA($_);
	my $species_in_genus=&get_species_in_genus($_);
	my $genera_in_family=&get_genera_in_family($_);
	my $etymology=&get_etymology($_);
	my $synonyms=&get_synonyms($_);
	my $reference=&get_reference($_); #added August 2017
	my $note=&get_note($_);
	my $ft_code=&get_flowering_time_code($_); #fetches the flowering time in the format needed for the "heath bar" display script
	my $is_terminal_taxon=&is_terminal_taxon($_);
	my $revision_number=&get_revision_number($_); #revision number is assigned based on which "TJM# AUTHOR" tags are used
	my $revision_date=&get_revision_date($_); #revision date is assigned based on which "TJM# AUTHOR" tags are used, added Mar2017, JAA

#the $full_formatted_display_name is the full name including authors and italics tags
#this is required since autonyms have their authority inserted after the species
#and infra taxa lacking a species treatment (ILST) need to have the species author included
#for display purposes (but not searching).

#This is tricky because you need to titlecase the genus separately for ILST names
#otherwise the authority gets all lowercased

if ($taxon_name =~ /ENCELIA farinosa &times; E. frutescens/){ #the spontaneous hybrid is kluged because there is only one and it's awkward
	$taxon_name = "Encelia farinosa &times; E. frutescens";
	$full_formatted_display_name = "<i>Encelia farinosa</i> &times; <i>E. frutescens</i>";
}
elsif ($taxon_name =~ /([A-Z]+) ([a-z-]+) (.+) (var\.|subsp\.) ([a-z-]+)$/){ #if it is an infra with an author inserted (that's the ".+")
	$genus = ucfirst(lc($1));
	$species = $2;
	$species_author = $3;
	$infra_rank = $4;
	$infra_epithet = $5;
	$taxon_name=ucfirst(lc($taxon_name));
	$taxon_name=&strip_name($taxon_name);
#print "$taxon_name\n";
	if ($species eq $infra_epithet){ #if it is an autonym, inserted author goes after specific epithet, and there is no $taxon_author
		$full_formatted_display_name = "<i>$genus $species</i> $species_author $infra_rank <i>$infra_epithet</i>";
	}
	else { #else the inserted author stays after the specific epithet, and the $taxon_author goes at the end
		$full_formatted_display_name = "<i>$genus $species</i> $species_author $infra_rank <i>$infra_epithet</i> $taxon_author";
	}
}
elsif ($taxon_name =~ /([A-Z]+) ([a-z-]+) (var\.|subsp\.) ([a-z-]+)$/){ #if it is an infra without an author in the name
	$genus = ucfirst(lc($1));
	$species = $2;
	$infra_rank = $3;
	$infra_epithet = $4;
	$taxon_name=ucfirst(lc($taxon_name));
	if ($species eq $infra_epithet){ #if it is an autonym, author goes after specific epithet
		$full_formatted_display_name = "<i>$genus $species</i> $taxon_author $infra_rank <i>$infra_epithet</i>";
	}
	else { #otherwise the author goes at the end
		$full_formatted_display_name = "<i>$genus $species</i> $infra_rank <i>$infra_epithet</i> $taxon_author";
	}
}
else { #The rest should be family, genus, or binomial species treatments
	$taxon_name=ucfirst(lc($taxon_name));
	$taxon_name=&strip_name($taxon_name);
	if ($taxon_author eq "NULL"){
		$full_formatted_display_name = "<i>$taxon_name</i>";
	}
	else {
		$full_formatted_display_name = "<i>$taxon_name</i> $taxon_author";
	}
}

$family=ucfirst(lc($family));

#Some families have alternate names in parens, e.g. "Asteraceae (Compositae)"
#first, make sure the alternate name is capitalized correctly
if ($taxon_name =~ /([A-Za-z]+) \((.*)\)/){ #can't have the parens as part of $2, otherwise the ucfirst function will target the open paren
	$taxon_name = $1 . " " . "(" . ucfirst($2) . ")"; 
} 
#then before matching to taxon ids, create a name_for_matching that removes the alternate name
$name_for_matching = $taxon_name;
foreach ($name_for_matching){
	s/ \(.*\)//;
	s/&times; ([A-Z])/&times;$1/;
}

$taxon_id=$TNOAN{$name_for_matching};
next unless $taxon_id;
#print "$TNOAN{$name_for_matching}\t$name_for_matching\n";
#print out the plain matched taxon names to file used by synonymy script
print FILE "$name_for_matching\n";

#test print
#print "$taxon_id\t$taxon_name\t$taxon_author\t$full_formatted_display_name\n";
#print "<tr><td>$taxon_id</td><td>$taxon_name</td><td>$taxon_author</td><td>$full_formatted_display_name</td</tr>\n";

#add single quotes to fields that were used for processing
$taxon_name="\'$taxon_name\'";
$taxon_author="\'$taxon_author\'" unless $taxon_author eq "NULL";
$full_formatted_display_name="\'$full_formatted_display_name\'";

#dist_codes are a shorter hexidecimal representation of a 40-character binary vector
#the 40 character vector indicates the presence or absence of a taxon in a bioregion
#the first 35 represent the 35 bioregions; the last five are blank spots (always 0)
#get_all_dist.pl translates bioregion distribution strings into the binary vector and packs it into hex
#here we unpack the hex so we can also store the binary vector in the database
#the binary is used by the online "checklist builder" pages
$dist_code=$HEX{$taxon_id};
$dist_code = &format_for_SQLite($dist_code);

$dist_array = unpack("b*",pack("H*",$HEX{$taxon_id}));
$dist_array = &format_for_SQLite($dist_array);


#use $taxon_id to determine whether there is a key or not
if($IJM_key{$taxon_id}){
	$has_key="1";
}
else{
	$has_key="NULL";
}

#rarity must be fetched last because it needs the $name_for_matching
	$rarity_status= &get_rarity($_);

#print "$taxon_name\t$has_key\n";
#print "$name\t$family\t$bioregion\t$elev\t$ecol\t$flow_per\t$outside_CA\n";
#print "$family\t$name\t$common_name\t$native_status\t$rarity\t$weediness\t$bioregion\n";
#print "$inflorescence\n"
#print join("\t",$name,@hv[0 .. 34]), "\n";
#print "$taxon_id\t$taxon_name\t$taxon_author\t$common_name\t$native_status\t$TJM2_author\t$habit\t$plant_body\t$stem\t$sterile_stem\t$fertile_stem\t$leaf\t$spines\t$inflorescence\t$staminate_head\t$ray_or_pistillate_flower\t$pistillate_head\t$staminate_inflorescence\t$pistillate_or_bisexual_inflorescence\t$pistillate_inflorescence\t$spikelet\t$fertile_spikelet\t$sterile_spikelet\t$distal_spikelet\t$central_spikelet\t$lateral_spikelet\t$staminate_spikelet\t$pistillate_spikelet\t$flower\t$staminate_flower\t$pistillate_flower\t$ray_flower\t$disk_flower\t$cone\t$pollen_cone\t$seed_cone\t$bisexual_flower\t$fruit\t$seed\t$sporangia\t$sporangium_case\t$male_sporangium_case\t$female_sporangium_case\t$spores\t$chromosomes\t$ecology\t$rarity_status\t$elevation\t$bioregional_distribution\t$outside_CA\t$species_in_genus\t$genera_in_family\t$etymology\t$toxicity\t$synonyms\t$unabridged_synonyms\t$note\t$unabridged_note\t$flowering_time\t$fruiting_time\t$coning_time\t$weediness\t$is_terminal_taxon\t$has_key, $revision_number, $dist_code\n";
#print "$taxon_name\t$taxon_id\n";
#print "$taxon_name\t$common_name\t$taxon_author\t$key_group\n";
#print "$taxon_name\t$taxon_id\t$dist_code\n";
#print "$taxon_id\t$bioregional_distribution\t$dist_code\t$dist_array\n";
#print "$taxon_id\t$taxon_name\t$full_formatted_display_name\n";
#print "$taxon_id\t$taxon_name\t$taxon_author\t$is_terminal_taxon\n";

print OUT "INSERT INTO eflora_taxa(AcceptedNameTID, ScientificName, TaxonAuthor, FormattedDisplayName, CommonName, KeyGroup, NativeStatus, TJM2Author, ScientificEditor, Habit, PlantBody, Stem, SterileStem, FertileStem, Leaf, Spines, Inflorescence, StaminateHead, RayOrPistillateFlower, PistillateHead, StaminateInflorescence, PistillateOrBisexualInflorescence, PistillateInflorescence, Spikelet, FertileSpikelet, SterileSpikelet, DistalSpikelet, CentralSpikelet, LateralSpikelet, StaminateSpikelet, PistillateSpikelet, Flower, StaminateFlower, PistillateFlower, RayFlower, DiskFlower, Cone, PollenCone, SeedCone, BisexualFlower, Fruit, Seed, Sporangia, SporangiumCase, MaleSporangiumCase, FemaleSporangiumCase, Spores, Chromosomes, Ecology, RarityStatus, Elevation, BioregionalDistribution, OutsideCA, SpeciesInGenus, GeneraInFamily, Etymology, Toxicity, Synonyms, UnabridgedSynonyms, Reference, UnabridgedReference, Note, UnabridgedNote, FloweringTime, FloweringTimeCode, FruitingTime, ConingTime, Weediness, IsTerminalTaxon, HasKey, RevisionNumber, RevisionDate, DistCode, DistArray)\n";
print OUT "VALUES($taxon_id, $taxon_name, $taxon_author, $full_formatted_display_name, $common_name, $key_group, $native_status, $TJM2_author, $scientific_editor, $habit, $plant_body, $stem, $sterile_stem, $fertile_stem, $leaf, $spines, $inflorescence, $staminate_head, $ray_or_pistillate_flower, $pistillate_head, $staminate_inflorescence, $pistillate_or_bisexual_inflorescence, $pistillate_inflorescence, $spikelet, $fertile_spikelet, $sterile_spikelet, $distal_spikelet, $central_spikelet, $lateral_spikelet, $staminate_spikelet, $pistillate_spikelet, $flower, $staminate_flower, $pistillate_flower, $ray_flower, $disk_flower, $cone, $pollen_cone, $seed_cone, $bisexual_flower, $fruit, $seed, $sporangia, $sporangium_case, $male_sporangium_case, $female_sporangium_case, $spores, $chromosomes, $ecology, $rarity_status, $elevation, $bioregional_distribution, $outside_CA, $species_in_genus, $genera_in_family, $etymology, $toxicity, $synonyms, $unabridged_synonyms, $reference, $unabridged_reference, $note, $unabridged_note, $flowering_time, $ft_code, $fruiting_time, $coning_time, $weediness, $is_terminal_taxon, $has_key, $revision_number, $revision_date, $dist_code, $dist_array)\n";
print OUT ";\n";
}






###########################################

sub format_for_SQLite {
	#given exactly one variable
	#if the variable has contents, put single quotes around the string
	#else, return "NULL" without quotes
	my ($input) = @_;
	if ($input){
		return "\'$input\'";
	}
	else {
		return "NULL";
	}
}

#sub strip_name {
#	local($_) = @_;
#	s/^([A-Z][-a-z]+) (X?[-a-z]+) .*(subsp\.|ssp\.|var\.|f\.) ([-a-z]+).*/$1 $2 $3 $4/ ||
#	s/^([A-Z][a-z]+) ([x ]*[-a-z]+) .*/$1 $2/;
#	s/ssp\./subsp./;
#	return ($_);
#}

sub basic_get {
	#for tags that don't require any special processing
	#the following basic formula is used
	#given the tage name as a second variable
	my($paragraph, $tag) = @_;
	if($paragraph =~ /$tag: *(.*)/){
		return "\'$1\'";
	}
	else {
		return "NULL";
	}
}

sub get_taxon_name {
    my $par = shift; #each paragraph is separated by a blank line
    @lines=split(/\n/,$par); #the array of lines within a paragraph are values separated by a new line
    if( $lines[0]=~/^NATIVE|NATURALIZED/){ #if the first line starts with...
        return $lines[1]; #the name is the contents of the second line
    }
    if( $lines[0]=~/^WAIF/){ #if the first line starts with...
        return $lines[1]; #the name is what's on the second line
    }
    elsif($lines[1]=~/^(JFP-4|JFP-8, does not occur in CA|JFP-8, accepted name for taxon not occurring in California|JFP-4, URBAN WEED|WAIF|AGRICULTURAL WEED|URBAN WEED|EXTIRPATED ALIEN|HISTORICAL WAIF|SPONTANEOUS HYBRID|GARDEN AND URBAN WEED|EXTIRPATED WAIF|AGRICULTURAL, GARDEN, OR URBAN WEED|URBAN WEED EXPECTED IN WILDLANDS|GARDEN WEED|EXTIRPATED WEED|CULTIVATED PLANT|EXTIRPATED)/){
        return $lines[2]; #elsif the second line starts with any of the above values, the name is what's on the third line
    }
    elsif($lines[0]=~/UNABRIDGED/){ #elsif the first line starts with "UNABRIDGED"
        return $lines[1]; #the name is what's on the second line
    }
    elsif( $lines[0]=~/^[A-Z][A-Z][A-Z]/){ #elsif the first line starts with three capital letters...
        return $lines[0] #the name is what's on the first line
    }
    else{ #otherwise...
        return "NULL"; #don't return anything for that paragraph
    }
}

sub get_taxon_author {
# taxon author is returned without single quotes, since it is used to generate the formatted display name
# single quotes are added later in the script
		my $par = shift;
		if($par=~/TAXON AUTHOR: *\n/){
			return "NULL";
		}
		elsif ($par=~/TAXON AUTHOR: *(.*) (\(Group.*\))/){
			return "$1";
		}
		elsif($par=~/TAXON AUTHOR: *(.*)/){
			return "$1";
		}
		else{
		return "NULL";
		}
}

sub get_common_name {
		my $par = shift;
		
		if($par=~/COMMON NAME: *(.*)\nUNABRIDGED COMMON NAME: *(.*)/){
			return "\'$1; $2\'";
		}
		
		elsif($par=~/COMMON NAME: *(.*) (\(Group.*\))/){
			return "\'$1\'";
		}
		
		elsif($par=~/COMMON NAME: *(.*)/){
			return "\'$1\'";
		}
		else{
		return "NULL";
		}
}

sub get_key_group { #Key Group comes at the end of the common name. If no common name, it's at the end of the taxon author
	my $par = shift;
	if($par=~/COMMON NAME: *(.*) \((Group.*)\)/){
			return "\'$2\'";
		}
	elsif($par=~/TAXON AUTHOR: *(.*) \((Group.*)\)/){
			return "\'$2\'";
		}
	else{
		return "NULL";
	}
}

sub get_native_status {
    my $par = shift; #each paragraph is separated by a blank line
    @lines=split(/\n/,$par); #the array of lines within a paragraph are values separated by a new line
    if( $lines[0]=~/^NATIVE|NATURALIZED/){ #if the first line starts with...
        return "\'$lines[0]\'"; #the name is the contents of the second line
    }
    if( $lines[0]=~/^WAIF/){ #if the first line starts with...
        return "\'$lines[0]\'"; #the name is what's on the second line
    }
    elsif($lines[1]=~/^(WAIF|AGRICULTURAL WEED|URBAN WEED|EXTIRPATED ALIEN|HISTORICAL WAIF|JFP-4|SPONTANEOUS HYBRID|JFP-8, does not occur in CA|GARDEN AND URBAN WEED|EXTIRPATED WAIF|AGRICULTURAL, GARDEN, OR URBAN WEED|URBAN WEED EXPECTED IN WILDLANDS|JFP-8, accepted name for taxon not occurring in California|JFP-4, URBAN WEED|GARDEN WEED|EXTIRPATED WEED|CULTIVATED PLANT)/){
        return "\'$lines[1]\'"; #elsif the second line starts with any of the above values, the name is what's on the third line
    }
    else {
    	return "NULL";
    }
}

sub get_TJM2_author {
		my $par = shift;
		if($par =~ /TJM4X AUTHOR: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJMXXX AUTHOR: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJMXX AUTHOR: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /TJMX AUTHOR: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~/TJM2 AUTHOR: *(.*)/){
			return "\'$1\'";
		}
		else{
			return "NULL";
		}
}

sub get_scientific_editor {
		my $par = shift;
		if($par =~ /SCIED: Scientific Editors?: *(.*)/){
			return "\'$1\'";
		}
		else{
			return "NULL";
		}	
}

sub get_habit {
		my $par = shift;
		if($par=~/HABIT\+: *(.*)/ && $par =~ /UNABRIDGED HABIT\+: *(.*)/){
			return "\'$1; $2\'";
		}
		elsif($par=~/HABIT\+: *\n/){ #The HABIT+ tag is always included, even if empty
			return "NULL";
		}
		elsif($par=~/HABIT\+: *(.*)/){
			return "\'$1\'";
		}
		else{
			return "NULL";
		}
}

sub get_stem {
		my $par = shift;
		if($par =~ /([\H])STEM: *(.*)/){
			return "\'$2\'";
		}
		elsif($par =~ /STEMS: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_leaf {
		my $par = shift;
		if($par =~ /LEAF: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /LEAVES: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_spines {
		my $par = shift;
		if($par =~ /SPINES: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /SPINE: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_inflorescence {
		my $par = shift;
		if($par =~ /([\H])INFLORESCENCE: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_spikelet {
		my $par = shift;
		if($par =~ /([\H])SPIKELET: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_flower {
		my $par = shift;
		if($par =~ /UNABRIDGED FLOWER: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /([\H])FLOWER: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_disk_flower {
		my $par = shift;
		if($par =~ /([\H])DISK FLOWER: *(.*)\nUNABRIDGED DISK FLOWER: *(.*)/){
			return "\'$2; $3\'";
		}
		elsif($par =~/([\H])DISK FLOWER: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_cone {
		my $par = shift;
		if($par =~ /([\H])CONE: *(.*)/){
			return "\'$2\'";
		}
		elsif($par =~ /CONES: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_sporangium_case {
		my $par = shift;
		if($par =~ /SPORANGIUM CASE: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /SPORANGIUM CASES: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_chromosomes {
		my $par = shift;
		if($par =~ /([\H])CHROMOSOMES: *(.*)\nUNABRIDGED CHROMOSOMES: *(.*)/){
			return "\'$2; $3\'";
		}
		elsif($par =~ /UNABRIDGED CHROMOSOMES: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /([\H])CHROMOSOMES: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_rarity {
#This stores the CNPS database ID for records with rarity status
#or if the ID is not available, the search terms to put in the CNPS search URL
		my $par = shift;
		if($par=~/RARITY STATUS: *(.*)/){
			if ($CNPS{$name_for_matching}) {
				return "\'$CNPS{$name_for_matching}\'";
			}
			else {
				$name_for_matching=~s/ subsp\. / ssp. /;
				$name_for_matching=~s/ /\+/;
				return "\'$name_for_matching\'";
			}
		}
		else{
		return "NULL";
			}
}

sub get_bioregion {
		my $par = shift;
		if($par=~/UNABRIDGED BIOREGIONAL DISTRIBUTION: *(.*)/){
			return "\'$1\'";
		}
		elsif($par=~/BIOREGIONAL DISTRIBUTION: *(.*)/){
			return "\'$1\'";
		}
		else{
		return "NULL";
		}
}

sub get_outside_CA {
		my $par = shift;
        if($par=~ m/UNABRIDGED DISTRIBUTION OUTSIDE CALIFORNIA: *(.*)/){
                return "\'$1\'";
        }
        elsif($par=~ m/DISTRIBUTION OUTSIDE CALIFORNIA: *(.*)/){
                return "\'$1\'";
        }
        else{
                return "NULL";
        }
}

sub get_species_in_genus {
		my $par = shift;
		if($par =~ /UNABRIDGED SPECIES IN GENUS: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /SPECIES IN GENUS: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_genera_in_family {
		my $par = shift;
		if($par =~ /UNABRIDGED GENERA IN FAMILY: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /GENERA IN FAMILY: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_etymology {
		my $par = shift;
		if($par =~ /UNABRIDGED ETYMOLOGY: *(.*)/){
			return "\'$1\'";
		}
		elsif($par =~ /ETYMOLOGY: *(.*)/){
			return "\'$1\'";
		}
		else {
			return "NULL";
		}
}

sub get_synonyms {
		my $par = shift;
		if($par =~ /([\H])SYNONYMS: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_reference {
		my $par = shift;
		if($par =~ /([\H])REFERENCE: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_note {
		my $par = shift;
		if($par =~ /([\H])NOTE: *(.*)/){
			return "\'$2\'";
		}
		else {
			return "NULL";
		}
}

sub get_flowering_time_code {
        my $entry = shift;
        undef @FT; 
        my @FT; #This needs to be done outside the loops, otherwise in cases where there are multiple ranges, the array will be overwritten
        if($entry=~/([A-Z][a-z][a-z])--([A-Z][a-z][a-z])/){ #searches the whole entry for ranges, because e.g. Coning time is recorded in the NOTES field
        	%monthno=("Jan",0,"Feb",1,"Mar",2,"Apr",3,"May",4,"Jun",5,"Jul",6,"Aug",7,"Sep",8,"Oct",9,"Nov",10,"Dec",11); #heath bar index starts at 0
            if($monthno{$1} > $monthno{$2}){
                foreach $no (0 .. $monthno{$2}){
                    push @FT, $no; 
                }
                foreach $no ($monthno{$1} .. 11){
                    push @FT, $no;
                }
            }
            else{
                foreach $no ($monthno{$1} .. $monthno{$2}){
                	push @FT, $no;
                }      
            }
            $FTCODE = join (",", @FT);
        	return "\'$FTCODE\'"; 
        }
        else{
            return "NULL";
        }
}

sub is_terminal_taxon {
        my $par = shift;
		if ($par=~ m/BIOREGIONAL DISTR/){
        	return 1;
        }
		else{
			return "NULL";
		}
}

sub get_revision_number {
	my $par = shift;
	if ($par =~ m/TJM4X AUTHOR:/){
		return "\'Revision 4\'";
	}
	elsif ($par =~ m/TJMXXX AUTHOR:/){
		return "\'Revision 3\'";
	}
	elsif ($par =~ m/TJMXX AUTHOR:/){
		return "\'Revision 2\'";
	}
	elsif ($par =~ m/TJMX AUTHOR:/){
		return "\'Revision 1\'";
	}
	else {
		return "NULL";
	}
}
#sub added Mar2017, JAA
sub get_revision_date {
	my $par = shift;
	if ($par =~ m/TJM4X AUTHOR:/){
		return "\'2016\'";
	}
	elsif ($par =~ m/TJMXXX AUTHOR:/){
		return "\'2015\'";
	}
	elsif ($par =~ m/TJMXX AUTHOR:/){
		return "\'2014\'";
	}
	elsif ($par =~ m/TJMX AUTHOR:/){
		return "\'2013\'";
	}
	else {
		return "\'2012\'";
	}
}